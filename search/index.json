[{"content":"\n여기에 쓰이는 글은 지극히 개인적인 생각입니다.\n내가 생각하는 개발자란? 개발자는 컴퓨터와 교감은 필수적이라 생각한다.\n그리고 짧은 경험이라 하더라도 뭐든 관심 있게 보는 것도 중요하다.\n그 교감과 경험으로 얻어진 노하우와 스킬로 개발을 하는것이\n개발자라 본다.\n물론, 나는 그 개발자가 되기 위해 노력하지만, 이런저런 핑계로 작동만 되게끔만 하는 코더에 불과하다 생각한다.\n어려움이 닥칠수록 기본에 집중하다 보면 어느순간 문제를 조금씩 해결해 나갈 수 있다고 생각한다.\n부트캠프 위에서 말한 코더는 취업하기 쉽지 않다 생각한다.\n왜냐하면 부트캠프에서 알려준 대로, 그리고 이미 많은 전 기수들의 면접 기록을 구글에 찾아보면\n정말 많은 글들이 나오고, 이미 업계에서는 이러한 사실을 알고 있는듯했다.\n이러한 경험을 어떻게 알고있냐면..나도 위코드 부트캠프에서 배웠기때문이다.\n문제점 멘토진들은 모두 2개월 같이 위코드에서 배운 동기들이거나 혹은 선배 기수들이다.\n나중에 안 사실이지만 정말 그랬다.\n수강료 800만원의 가치가 훅 떨어지는 순간이다.\n물론 위코드만의 방식이였겠지만 3개월 동안 같은 내용의 커리큘럼을 받은 사람에게 같은 내용을 전수받고있었다니\n정말 기분이 나빴다.\n어떠한 멘토는 \u0026lsquo;이커머스 회사에 다니다 왔는데 실무는 정말 힘들다\u0026rsquo; 라고 말했지만\n기록들을 찾아보니 이커머스는 커녕 그냥 몇 기수 전에 수료한 수료생이었다.\n그러면서 꺼드럭거리는 모습을 생각해보니 기가 찬다.\n이러한 말도 안 되는 커리큘럼을 진행하면서 3개월 만에 취업을 할 수있다?\n처음에는 나도 혹해서 진행을 한거였지만, 수료 후 + 3개월만에 취업을 하고\n현재 실무를 하며 느낀 점은 로마는 하루아침에 이루어지지 않았다 를 뼈저리게 느낀다.\n얼마 전 나온 뉴스를 보면 https://www.joongang.co.kr/article/25098667\n정말 공감이 된다.\n추가적으로 이 글을 보시는 부트캠프 지망생분들은, 돈으로 의지를 사지마시고\n4년동안 열심히 전공하고 일하시는분들을 생각하며\n국비지원등을 통하여 준비하는걸 추천드립니다.\n","date":"2022-09-04T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/188311938-60d9948c-a334-45e5-9852-04d2ff5b2b5b.png","permalink":"https://heetaek.com/p/%EC%9E%A1%EB%8B%B4-%EC%9C%84%EC%BD%94%EB%93%9C-%ED%9B%84%EA%B8%B0-%EB%A1%9C%EB%A7%88%EB%8A%94-%ED%95%98%EB%A3%A8%EC%95%84%EC%B9%A8%EC%97%90-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%80%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4/","title":"[잡담] 위코드 후기, 로마는 하루아침에 이루어지지 않았다"},{"content":"Go 언어로 Redis pubsub 구현 필수 패키지 Mac 기준입니다.\nbrew install redis brew 로 redis 설치하게 되면 Redis7 로 설치됩니다.\n저희가 사용할 go-redis 는 현재 Redis6 가 stable 버전임을 참고바랍니다.\ngo get github.com/go-redis/redis/v8 v8 = Redis6 (stable)\nv9 = Redis7 (beta)\n하지만 테스트 해본결과 큰 문제가 없습니다.\n라우터의 경우 뭘 사용해도 상관없습니다. (다만 body 바인딩 부분에서 조금의 차이가 있을 수 있습니다.)\n저는 AWS API Gateway 와 AWS Lambda 도 같이 사용할수있는\nhttp 라우터 golam 을 사용하였습니다.\ngo get github.com/unsafe-risk/golam PubSub 구현 먼저 redis 의 pubsub 아키텍처가 무엇인지 확인해보자.\n참고링크 : https://medium.com/frientrip/pub-sub-%EC%9E%98-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-de9dc1b9f739\nkafka 와 redis 아키텍쳐에 대한 비교글도있으니 참고하면 좋을듯싶다.\n나중에 kafka 에 대해서도 다뤄볼 기회가 있다면 다뤄보고싶다.\nRedis 의 PubSub 아키텍처 ├── go.mod ├── go.sum ├── redis │ ├── dump.rdb │ ├── pub │ │ └── main.go │ └── sub │ └── main.go publisher 의 경우 golam 으로 라우팅하여 POST 메소드로 메시지를 채널로 전송하였습니다.\nsubscriber 는 redis 채널로 메시지를 전송받게끔 구현하였습니다.\npub/main.go var redisClient = redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) var ctx = context.Background() type User struct { Name string `json:\u0026#34;name\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` } func main() { g := golam.New() g.POST(\u0026#34;/\u0026#34;, PostString) log.Print(\u0026#34;Start server\u0026#34;) err := g.StartWithLocalAddr(\u0026#34;:3000\u0026#34;) if err != nil { log.Print(err) } } func PostString(c golam.Context) error { var user User body := c.Request().Body data := []byte(body) json.Unmarshal(data, \u0026amp;user) payload, err := json.Marshal(user) if err != nil { panic(err) } if err := redisClient.Publish(ctx, \u0026#34;채널명\u0026#34;, payload).Err(); err != nil { log.Print(err) } return c.String(http.StatusOK, \u0026#34;good\u0026#34;) } redis 의 기본 포트인 6379 로 새로운 클라이언트 시작\nvar redisClient = redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) Publish 메소드를 보면 채널에 메시지를 작성한다네요\n필요한 인자는 채널명과 메시지네요.\n채널명과 메시지를 적어줍시다.\n메시지는 payload 에 json 마샬링이 된 User 구조체가 담겨져있습니다.\n이렇게 하면 publisher 는 완성이 되었습니다.\nif err := redisClient.Publish(ctx, \u0026#34;채널명\u0026#34;, payload).Err(); err != nil { log.Print(err) } subscriber 를 마무리 해봅시다.\nsub/main.go var ctx = context.Background() var redisClient = redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) type User struct { Name string `json:\u0026#34;name\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` } func main() { subscriber := redisClient.Subscribe(ctx, \u0026#34;채널명\u0026#34;) user := User{} for { msg, err := subscriber.ReceiveMessage(ctx) if err != nil { panic(err) } if err := json.Unmarshal([]byte(msg.Payload), \u0026amp;user); err != nil { panic(err) } fmt.Println(\u0026#34;메시지가\u0026#34; + msg.Channel + \u0026#34; 채널에서 왔습니다.\\n\\n\u0026#34;) fmt.Printf(\u0026#34;%+v\\n\\n\u0026#34;, user) } } subscriber 는 메시지를 받는 입장이니 publisher 채널을 구독해주어야겠죠.\npublisher 에서 생성했던 채널을 구독해줍시다.\nsubscriber := redisClient.Subscribe(ctx, \u0026#34;채널명\u0026#34;) 그리고 반복문을 돌며 메시지를 수신해주도록 하면됩니다.\nfor { msg, err := subscriber.ReceiveMessage(ctx) if err != nil { panic(err) } if err := json.Unmarshal([]byte(msg.Payload), \u0026amp;user); err != nil { panic(err) } fmt.Println(\u0026#34;메시지가\u0026#34; + msg.Channel + \u0026#34; 채널에서 왔습니다.\\n\\n\u0026#34;) fmt.Printf(\u0026#34;%+v\\n\\n\u0026#34;, user) } 실행 터미널 두개로 pub 과 sub 두개를 동시에 실행하였습니다.\npublisher 실행\ncd pub go run main.go subscriber 실행\ncd sub go run main.go ","date":"2022-08-22T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/185876174-e54c99ee-cf3c-42f4-935b-1061219949a6.png","permalink":"https://heetaek.com/p/go-go%EC%96%B8%EC%96%B4%EB%A1%9C-redis-pub-sub-%EA%B5%AC%ED%98%84/","title":"[Go] Go언어로 redis pub sub 구현"},{"content":"N + 1 문제란? ORM 의 연관 관계에서 발생하는 문제다. 예를 들어 여러 개의 상품 구매 목록을 가지고 있는 쇼핑몰 유저다.\nUser 와 Order 테이블이 1:N 관계로 설정되어있다 가정하고\n특정 유저를 조회했을때 SELECT 문은 1번 실행되고, 해당 유저와 관련된 상품을 N 번 더 조회하게 된다.\nN + 1 문제를 해결하기 전에 관련된 중요한 개념인 Eager Loading 과 Lazy Loading 에 대해 알아야한다.\nEager Loading 이란? Eager Loading 이란 즉시 로딩으로 로딩 시 참조해야 할 데이터들을 미리 전부 가져옵니다.\n연관되어있는 데이터들을 한 번에 가져올 수 있다는 장점이 있지만, 초기 로딩 시 속도가 느려질 수 있다는 특징이 있다.\nLazy Loading 이란? Lazy Loading 이란 말 그대로 지연 로딩이라 한다.\nEager Loading 과 반대로 필요한 순간에만 데이터를 가져온다.\nEager Loading 과 Lazy Loading 에 대해 알아보았으니\n더 쉽게 예시를 들어보면서 자세히 알아보자.\n다른 ORM 은 어떤 방식으로 동작하는지 모르겠지만, 검색을 해보면 대부분 Spring 의 JPA 예제뿐이다.\nDjango N+1 예제 Place모델과 Restaurant모델\nclass Place(models.Model): name = models.CharField(max_length=50) address = models.CharField(max_length=80) def __str__(self): return self.name class Restaurant(models.Model): place = models.OneToOneField(Place, on_delete=models.CASCADE, related_name=\u0026#39;restaurant\u0026#39;) name = models.CharField(max_length=50) severs_pizza = models.BooleanField(default=False) def __str__(self): return self.name Place모델과 Restaurant모델은 일대일 관계 각각 6개만 레코드를 생성합니다. 아래는 이미 생성한 결과 화면입니다.\n\u0026gt;\u0026gt;\u0026gt; for place in Place.objects.all(): ... print(place.restaurant.name) ... TestRestaruant1 TestRestaruant2 TestRestaruant3 TestRestaruant4 TestRestaruant5 TestRestaruant6 이 때 생성되는 쿼리들은 아래와 같습니다.\nfrom django.db import connection print(connection.queries) [{\u0026#39;sql\u0026#39;: \u0026#39;SELECT @@SQL_AUTO_IS_NULL\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_place`.`id`, `photo_place`.`name`, `photo_place`.`address` FROM `photo_place`\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_restaurant`.`id`, `photo_restaurant`.`place_id`, `photo_restaurant`.`name`, `photo_restaurant`.`severs_pizza` FROM `photo_restaurant` WHERE `photo_restaurant`.`place_id` = 1 LIMIT 21\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_restaurant`.`id`, `photo_restaurant`.`place_id`, `photo_restaurant`.`name`, `photo_restaurant`.`severs_pizza` FROM `photo_restaurant` WHERE `photo_restaurant`.`place_id` = 2 LIMIT 21\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_restaurant`.`id`, `photo_restaurant`.`place_id`, `photo_restaurant`.`name`, `photo_restaurant`.`severs_pizza` FROM `photo_restaurant` WHERE `photo_restaurant`.`place_id` = 3 LIMIT 21\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_restaurant`.`id`, `photo_restaurant`.`place_id`, `photo_restaurant`.`name`, `photo_restaurant`.`severs_pizza` FROM `photo_restaurant` WHERE `photo_restaurant`.`place_id` = 4 LIMIT 21\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_restaurant`.`id`, `photo_restaurant`.`place_id`, `photo_restaurant`.`name`, `photo_restaurant`.`severs_pizza` FROM `photo_restaurant` WHERE `photo_restaurant`.`place_id` = 5 LIMIT 21\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.001\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_restaurant`.`id`, `photo_restaurant`.`place_id`, `photo_restaurant`.`name`, `photo_restaurant`.`severs_pizza` FROM `photo_restaurant` WHERE `photo_restaurant`.`place_id` = 6 LIMIT 21\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}] 쿼리셋에 담겨있는 내용을 호출하면\n담겨있는 N번 만큼의 수량이 호출이 되는 것을 볼 수 있다.\n만약 10만개의 데이터를 호출하면 SELECT 문도 똑같이 10만번 호출되는 문제다.\n이 때 prefetch_related 를 사용하여 Eager Loading 을 하게되면\n\u0026gt;\u0026gt;\u0026gt; for place in Place.objects.prefetch_related(\u0026#39;restaurant\u0026#39;).all(): ... print(place.restaurant.name) ... TestRestaruant1 TestRestaruant2 TestRestaruant3 TestRestaruant4 TestRestaruant5 TestRestaruant6 [{\u0026#39;sql\u0026#39;: \u0026#39;SELECT @@SQL_AUTO_IS_NULL\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_place`.`id`, `photo_place`.`name`, `photo_place`.`address` FROM `photo_place`\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}, {\u0026#39;sql\u0026#39;: \u0026#39;SELECT `photo_restaurant`.`id`, `photo_restaurant`.`place_id`, `photo_restaurant`.`name`, `photo_restaurant`.`severs_pizza` FROM `photo_restaurant` WHERE `photo_restaurant`.`place_id` IN (1, 2, 3, 4, 5, 6)\u0026#39;, \u0026#39;time\u0026#39;: \u0026#39;0.000\u0026#39;}] 확실히 쿼리가 줄은것을 볼 수 있다.\nReference\nhttps://zetawiki.com/wiki/N%2B1_%EC%BF%BC%EB%A6%AC_%EB%AC%B8%EC%A0%9C https://daeguowl.tistory.com/171 https://velog.io/@kim6515516/npuls https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping https://choidr.tistory.com/entry/TypeORM-N-1-%EB%AC%B8%EC%A0%9C ","date":"2022-06-26T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181750002-1bb8b82d-2288-4f1b-9c96-455e85db9bdf.png","permalink":"https://heetaek.com/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-n--1-%EB%AC%B8%EC%A0%9C/","title":"[데이터베이스] N + 1 문제"},{"content":"격리 수준(Isolation Level) 격리 수준이란 트랜잭션들끼리 일관된 데이터들을 얼마나 허용할것인지를 정하는 수준이다.\n쉽게 말해 동시에 데이터베이스에 접근할 때 그 접근을 어떻게 제어할지에 대한 설정이다.\n격리 수준에는 총 4가지의 수준이 있다.\nRead-Uncommitted (레벨 0) Read-Commited (레벨 1) Repeat-Read (레벨 2) Serializable (레벨 3) 밑으로 갈 수록 격리 수준은 높아지지만 성능은 떨어진다.\n데이터 정확성과 성능이 반비례하므로 상황에 따라 잘 선택하는것이 중요하다.\nIsolation Level 종류 Read-Uncommitted (레벨 0) SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층 트랜잭션이 처리중이거나 아직 commit 되지않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다. 데이터베이스의 일관성을 유지하는 것이 불가능하다. Dirty Read 발생 A 트랜잭션에서 10번 유저의 나이를 28에서 29으로 바꾸고, 아직 커밋하지않았다. B 트랜잭션에서 10번 유저의 나이를 조회 : 결과 = 28 -\u0026gt; 더티 리드(Drity Read) 이후 A 트랜잭션에서 문제가 발생해 Rollback B 트랜잭션은 10번 유저가 여전히 29살이라 생각하고 로직을 수행 이런식으로 데이터 정합성에 문제가 생긴다. Read-Committed (레벨 1) SELECT 문장이 수행되는 동안 해당 데이터에 Shard Lock이 걸리는 계층 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다. commit 이루어진 트랜잭션만 조회가 가능하다. Non-Repeatable Read 발생 B 트랜잭션에서 10번 유저의 나이를 조회: 결과 28 A 트랜잭션에서 10번 유저의 나이를 28에서 29로 바꾸고 commit B 트랜잭션에서 10번 유저의 나이를 조회 : 결과 29 Repeat-Read (레벨 2) 트랜잭션이 완료될 때까지 SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸리는 계층 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장한다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터를 수정이 불가능하다. Phantom Read 발생 Serializable (레벨 3) 트랜잭션이 완료될 때까지 SELECT 문장이 사용되는 모든 데이터에 Shard Lock이 걸리는 계층 가장 엄격한 격리 수준으로 완벽한 읽기 모드를 제공한다. 다른 사용자는 트랜잭션에 영역에 해당되는 데이터를 수정 및 입력이 불가능하다. 일반적인 온라인 서비스에서는 Read Commited 나 Repeat-Read 중 하나를 사용한다\n오라클을 포함한 대부분의 DBMS 는 Read-Commited 이 기본 레벨이고,\nMySQL 은 기본 레벨은 Repeat-Read 이다.\n레벨 별 허용되는 이상 현상 Isolation Level Dirty Read Non-Repeatable Read Phantom Read Read Uncommitted(Level 0) 허용 허용 허용 Read Committed(Level 1) X 허용 허용 Repeat-Read(Level 2) X X 허용 Serializable(Level 3) X X X 그럼 Dirty Read , Non-Repeatable Read, Phantom Read 가 뭔지 알아보자.\nDirty Read\n어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우. 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상 Non-Repeatable Read\n한 트랜잭션에서 같은 쿼리를 두 번 수행할 떄 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 다르게 나타나는 일관성이 깨진 현상 한 트랜잭션에서 똑같은 SELECT 를 수행했을 때 항상 같은 결과를 반환해야한다는 Repeatable Read 정합성에 어긋난다. Phantom Read\n한 트랜잭션 안에서 일정 범위의 레코드를 두 번 읽었을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타난다. 이렇게 격리 수준 레벨에 대한 이론적인것을 살펴보았지만,\n실제 실무에서는 어떻게 다뤄질지 전혀 감이 잡히지 않는다.\n아직은 어려운 주제인것같다.\nReference\nhttps://www.youtube.com/watch?v=e9PC0sroCzc https://devjem.tistory.com/27 https://wonit.tistory.com/463?category=790502 ","date":"2022-06-26T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749234-419a017c-7eef-4373-ab51-c3464c6e490a.png","permalink":"https://heetaek.com/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80transaction-isolation-level/","title":"[데이터베이스] 트랜잭션 격리 수준(Transaction isolation Level)"},{"content":"트랜잭션(Transaction) 트랜잭션은 데이터베이스 내에서 수행되는 작업의 최소 단위로, 데이터베이스의 무결성을 유지하며,\n데이터베이스의 상태를 변화시키는 기능을 수행한다.\n데이터베이스의 상태를 변경시킨다는 것은 SELECT,UPDATE, INSERT, DELETE 와 같은 행동을 뜻한다.\n트랜잭션은 하나 이상의 query 를 포함해야하고 ACID 라 칭해지는 원자성, 일관성, 고립성, 지속성의 4가지 규칙을 만족해야한다.\n왜 필요한가? 데이터베이스에서 트랜잭션이 필요한 이유는 데이터를 다룰 때 장애가 일어나는 경우\n트랜잭션은 장애 발생 시 데이터를 복구하는 작업의 단위가 되기 때문이다.\n또한 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때 트랜잭션을 통해 작업을 분리하고, 이를 통해 오류가 발생하지 않게 한다.\n은행 어플에서 A가 B에게 100만원을 입금하는 상황으로 예시를 들어보면\nA 의 계좌에서 100만원을 B의 계좌로 입금을 하려했는데 전산오류가 생겨 B의 계좌에는 100만원이 입금 되지 않았다\n정상적으로 처리가 됐다면 아래의 SQL 문처럼 실행되어야한다.\nSTART TRANSACTION // A 계좌에서 잔액 가져옴 A = 1000 // B 계좌에서 잔액 가져옴 B = 1000 // A 출금 A = A - 100 // B 입금 B = B + 100 UPDATE User SET balance = balance - 100 WHERE name=\u0026#39;A\u0026#39;; UPDATE User SET balance = balance + 100 WHERE name=\u0026#39;B\u0026#39;; // A 계좌 잔액 저장 A = 900 // B 계좌 잔액 저장 B = 1100 COMMIT 이렇게 예상치 못한 오류가 발생하여 데이터의 부정합이 발생하는 경우 다시 원상복구를 해야한다.\n따라서, 모든 입출금은 하나의 묶음 형태로 작동해야한다.\n입금과 출금은 분리될 수 없는 하나의 거래로 처리되어야하는 단일 업무 다.\n이러한 업무 처리의 최소단위를 데이터베이스에서 트랜잭션이라한다.\n트랜잭션의 특징(ACID) 트랜잭션은 데이터베이스의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성 총 4가지의 특징을 가지고있다.\n원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 말아야 한다 (all or nothing)\n일관성(Consistency) : 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. ex) 송금 전 후 모두 잔액의 데이터 타입은 int 여야한다는 것이 일관성의 한 예시가 될 수 있다.\n고립성(Isolation) : 여러 트랜잭션은 동시에 수행한다. 따라서 동시에 수행되는 트랜잭션이 동일한 데이터를 가지고 충돌하지 않도록 제어해줘야한다.\n지속성(Durability) : 성공적으로 수행된 트랜잭션은 데이터베이스에 영원히 반영되어야 한다. 트랜잭션이 완료되어 저장이 된 데이터베이스는 저장 후에 생기는 정전, 장애, 오류 등에 영향을 받지 않아야 한다. 보통 commit 이 된다면 지속성은 만족 할 수 있다.\n트랜잭션의 Commit 과 Rollback Commit 하나의 트랜잭션이 성공적으로 끝나서 데이터베이스가 일관성있는 상태에 있음을 의미한다.\nRollback 트랜잭션의 원자성이 깨질 때, 즉 하나의 트랜잭션 처리가 비정상적으로 종료 되었을 때의 상태를 뜻한다.\nRollback 이 이뤄진다면 트랜잭션을 다시 실행하거나 부분적으로 변경된 결과를 취소할 수 있다.\nReference\nhttps://devjem.tistory.com/27 https://wonit.tistory.com/462#google_vignette https://www.javatpoint.com/mysql-transaction ","date":"2022-06-25T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749234-419a017c-7eef-4373-ab51-c3464c6e490a.png","permalink":"https://heetaek.com/p/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98transaction-%EC%9D%B4%EB%9E%80/","title":"[데이터베이스] 트랜잭션(Transaction) 이란?"},{"content":"동시성(Concurrency) 동시성은 동시에 실행되는 것처럼 보이는 것이다.\n\u0026lsquo;동시\u0026rsquo; 라고 이야기 하지만 컴퓨터(코어)는 한번에 하나의 명령어만 처리 할 수 있다.\n위의 사진과 같이 Thread A 와 Thread B 가 Context Switching 을 통해 여러 개의 스레드를 번갈아 가면서 실행되는 방식이다.\n병렬성(Parallelism) 병렬성은 2개 이상의 코어에서 알고리즘이 동시에 정확히 실행 되는 것이다.\n동시성과는 다르게 여러 작업이 여러 스레드에서 각각 처리된다.\n결론은 한번에 여러일을 처리가 가능한것이다.\n사실 위의 글을 정리하면서 와닿지 않는 부분이 있었는데\n그림을 보고 이해가 갔다.\n커피 머신 한 대에 2줄로 서서 가져가는 카페와\n커피 머신 두 대에 1줄씩 서서 가져가는 카페\n모두 Concurrent 하다 볼 수 있다.\n병렬성도 동시성에 속하기 때문이다.\nReference\nhttps://seamless.tistory.com/42 https://www.charlezz.com/?p=44646 https://devsrkim.tistory.com/entry/%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1%EC%9D%98-%EC%B0%A8%EC%9D%B4?category=873361 ","date":"2022-06-25T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749273-405db335-e97d-4252-9fd4-1e875d355edf.png","permalink":"https://heetaek.com/p/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%8F%99%EC%8B%9C%EC%84%B1concurrency-%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1parallelism-%EC%9D%98-%EC%B0%A8%EC%9D%B4/","title":"[운영체제] 동시성(Concurrency) 과 병렬성(Parallelism) 의 차이"},{"content":"프로세스(Process) 우리 컴퓨터에서 실행 할 수 있는것을 프로그램 이라 한다.\n그리고 프로그램 이 실행이 되어 돌아가고 있는 상태를 프로세스 라 한다.\n글을 쓰고 있는 상태에서도 내 PC에서는 프로세스 가 저렇게 많이 켜져있다.\n위의 사진 처럼 여러 프로세스들이 함께 돌아갈 수 있는 이유는 나중에 더 깊게 다룰 것이지만,\n동시적, 병렬적 이 둘의 혼합으로 이루어진다.\n간단히 설명하자면,\n동시성(Concurrency)은 프로세서(CPU) 하나가 진행 중인 작업을 계속 바꿔준다.\n바꿔주는 작업을 Context Switching 이라 한다.\n이 과정이 사람이 눈치 챌 수 없을만큼 빠르게 진행되다보니 동시에 진행되는것처럼 느끼는것이다.\n병렬성(Parallelism)은 프로세서(CPU) 하나에 코어가 여러개 달려있어, 각각 동시에 작업들을 수행하는 것을 뜻한다.\n듀얼코어, 쿼드코어, 옥타코어 등 멀티코어 프로세서에서 할 수 있는 방식이다.\n스레드(Thread) 지금까지 PC는 여러개의 프로세스를 어떻게 함께 돌리는지 방법을 알아보았다.\n그러면 프로그램에서의 예시를 들어보자면 크롬 브라우저도 하나의 프로세스이다.\n넷플릭스로 영화를 보면서 이메일도 확인해야하고 게임도 다운로드 받아야한다.\n이렇게 한 프로세스에서도 여러 작업이 동시에 진행되어야하는데, 그 여러 작업을 스레드 라 부른다.\n멀티프로세스? 멀티스레드? 먼저 멀티프로세스와 멀티스레드의 용어의 정의를 살펴보자\n멀티 프로세스 : 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것.\n멀티 스레드 : 하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것.\n종류 장점 단점 멀티프로세스 하나의 프로세스가 죽어도 다른 프로세스에게는 영향을 끼치지 않는다. 각각 독립된 메모리 영역을 갖고 있어 작업량이 많은 수록 오버헤드가 발생하고 Context Switching으로 인한 성능 저하를 유발한다. 멀티스레드 프로세스의 응답시간이 단축되고 시스템의 처리율이 향상된다. 또한 코드 영역을 공유하기 때문에 자원 소모가 적다. 프로그램 디버깅이 어렵고 하나의 스레드에 문제가 생기면 전체적인 프로세스에 영향을 끼치게 된다. Reference\nhttps://www.youtube.com/watch?v=LLiV5Yz1AWg https://www.youtube.com/watch?v=RrfASw-jfZ4\u0026ab_channel=AIHolic https://blog.naver.com/sjc02183/221844611260 ","date":"2022-06-24T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749139-eea7573e-57c9-41c4-aadb-c0624df0e139.png","permalink":"https://heetaek.com/p/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9Cthread/","title":"[운영체제] 프로세스(Process)와 스레드(Thread)"},{"content":"프로토콜이란? 일상생활에서 지켜야 하는 규칙이 있듯이, 네트워크에서도 문제없이 통신하려면 규칙을 지켜야한다.\n예를 들어 프랑스어를 못하는 한국인과 한국어를 못하는 프랑스인이 만나면 대화가 불가능하다.\n그러면 영어로 대화한다는 규칙을 정해 놓으면 문제없이 대화가 가능하다.\n이와 같은 규칙을 네트워크에서는 프로토콜 이라고 한다.\n일상생활에서 접할 수 있는 편지를 예시로 들어보면\n편지를 써서 우체통에 넣으면 우체부가 편지를 수거한다. 수거한 편지는 우체국으로 가져가 분류한다. 분류된 편지들은 우체부가 가까운 우체국으로 편지를 운송하고, 수신자들은 우편함에서 찾아간다. 그러나 1 에서 편지를 쓰는 과정에서 주소를 적지 않았거나, 우표를 붙이지 않았다면 우체부는 수신처를 알 수 없으므로 가져다 줄 수 없다.\n이와 같이 편지가 전송되는 과정에는 \u0026lsquo;편지를 쓰는 규칙\u0026rsquo;, \u0026lsquo;편지를 보내는 규칙\u0026rsquo;, \u0026lsquo;우체국의 규칙\u0026rsquo; 등 여러가지 규칙이 있는데 서로 영향을 주지 않는다.\nOSI 7 Layers OSI 7 계층은 위와 같이 생겼다.\n저 OSI 7 계층이 왜 나왔냐면 지금은 생각조차 할 수 없지만 예전에는 같은 회사의 컴퓨터 끼리만 통신이 가능했다.\n예를 들어, Apple 과 Microsoft 사의 컴퓨터와는 통신이 불가능 했다.\n이런 일들이 있어서 공통으로 사용할 수 있는 표준 규격을 정해야만 했다.\nISO 라는 국제표준화 기구가 있는데 이 단체에서 OSI 모델 이라는 표준 규격을 제정했다.\n그럼 7계층은 왜 나누어 놨을까라는 의문이 생길수있는데 통신이 일어나는 과정을 단계별로 알 수 있고 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문이라한다.\nOSI 모델 각 계층의 역할 계층 이름 설명 7계층 애플리케이션 계층(Application Layer 이메일 \u0026amp; 파일 전송, 웹 사이트 조회 등 애플리케이션에 대한 서비를 제공 6계층 프레젠테이션 계증(Presentation Layer) 문자 코드, 압축, 암호화 등의 데이터를 변환 5계층 세션 계층(Session Layer) 세션 체결, 통신 방식을 결정 4계층 전송 계층(Transport Layer) 신뢰할 수 있는 통신을 구현 3계층 네트워크 계층(Network Layer) 다른 네트워크와 통신하기 위한 경로 설정 및 논리 주소를 결정 2계층 데이터 링크 계층(Data Link Layer) 네트워크 기기 간의 데이터 전송 및 물리 주소를 결정 1계층 물리 계층(Physical Layer) 시스템 간의 물리적인 연결과 전기 신호를 변환 및 제어 서로 데이터를 주고 받을 때는\n데이터를 송신 할 때는 7계층에서부터 1계층까지 하위 계층으로 데이터를 전달 하고\n데이터를 수신 받을 때는 1계층에서부터 7계층까지 상위 계층으로 데이터를 전달한다.\n가끔 로드밸런싱에 관한 글을 보면 L4 , L7 이라는게 나오는데 4 와 7 이 네트워크 계층이라는걸 OSI7 을 보고 알았다.\nTCP/IP 모델 TCP/IP 모델이란 7계층을 4계층으로 바꿔서 생각하면 이해하기 쉽다.\n아래 그림과 같이 4계층으로 이루어져있다. OSI 모델의 응용 계층, 표현 계층, 세션 계층이 TCP/IP 모델에서는 응용 계층으로 합쳐져 있다.\nReference\n모두의 네트워크 https://gyoogle.dev/blog/computer-science/network/OSI%207%EA%B3%84%EC%B8%B5.html ","date":"2022-06-20T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749554-a06e6898-7f00-4daa-be9e-f84323b307d0.png","permalink":"https://heetaek.com/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B7%9C%EC%B9%99-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-osi-%EB%AA%A8%EB%8D%B8%EA%B3%BC-tcp/ip-%EB%AA%A8%EB%8D%B8/","title":"[네트워크] 네트워크의 기본 규칙 (프로토콜, OSI 모델과 TCP/IP 모델)"},{"content":"스택 (Stack) 스택(Stack)은 \u0026lsquo;쌓다\u0026rsquo; 라는 의미로, 데이터를 쌓아 올린 형태의 자료구조이다.\n접근 방법은 LIFO(Last In First Out) 라고 부르며, 마지막에 넣은 요소가 먼저 나온다는 의미다.\n아래가 막혀있고 위가 뚫린 형태로 차곡차곡 쌓인다.\n이러한 구조이기때문에 마지막에 삽입한 요소는 처음으로 삭제할 수 있다.\n스택에서 삽입은 PUSH, 삭제는 POP 이라는 용어로 사용하고 있다.\n실사용 예제 브라우저에서 뒤로 가기 문서작업에서 Ctrl + Z 실행취소 (undo) 후위 표기법 (컴퓨터가 어떤식으로 사칙 연산을 하는지 이해하는 용도) 큐(Queue) 큐는 단순히 스택의 반대 개념이다.\n접근 방법은 FIFO (First In First Out)라고 부르며, 먼저 들어간 데이터가 먼저 나오는 구조다.\n은행업무를 보기 위해 줄을 선 모습을 상상해 볼 수 있다.\n번호표를 먼저 뽑은 사람이 먼저 업무를 처리하고 나가고, 말 그대로 \u0026lsquo;FIFO\u0026rsquo; 다.\n또 다른 예시로 CPU 는 하나의 task 가 처리가 완료되어야 다음 task 로 넘어가 처리하는것처럼 실행 순서대로 처리한다.\n실사용 예제 은행 업무 프린터에서 여러 문서를 순서대로 인쇄 Reference\nhttps://www.fun-coding.org/Chapter06-stack-live.html https://www.fun-coding.org/Chapter05-queue-live.html https://hanamon.kr/%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0-queue-%ed%81%90-feat-buffering/ ","date":"2022-05-13T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181748733-7a45d5ed-1ed3-454f-808f-19f470c19353.png","permalink":"https://heetaek.com/p/stack-queue/","title":"[자료구조] 스택(Stack) 과 큐(Queue)"},{"content":"Array (배열) 데이터가 많아지면 그룹 관리의 필요성이 생긴다. 이럴 때 사용하는 것이 배열이다. 하나의 변수에 여러 데이터를 담을 수 있다. 파이썬에서는 배열이라는게 없고 리스트가 배열 기능을 제공한다.\n그래서 C로 예시를 들어보자면\nint Array[5] = {13, 42, 33, 95, 11, 28} Index 0 1 2 3 4 5 Element 13 42 33 95 11 28 위의 표와 같이 Index 는 0 부터 시작하고 배열의 사이즈에 맞게 들어가는것을 볼 수 있다.\n배열의 특징 미리 최대 크기를 지정해야 한다. 엘리먼트의 인덱스는 변하지 않는다. (예를들면 주민번호) 인덱스를 활용하여 빠르게 조회가 가능하다. List (리스트) 리스트와 배열은 같은 다중 자료형이지만 다른 속성을 가지고있다. 리스트는 배열이 가지고있는 인덱스라는 장점을 버리고 빈틈없는 데이터의 적재 라는 장점을 가진 자료구조이다. 데이터 갯수가 확실하게 정해져 있고, 자주 사용된다면 배열이 더 효율적이다. 파이썬 리스트 예시\narray = [13, 42, 33, 95, 11, 28] for li in array: print(li) # 13, 42, 33, 95, 11, 28 평소에 사용하던 리스트가 파이썬에서는 배열이다. 파이썬의 리스트는 크기가 가변적이고 어떤 타입이던지 저장할 수 있는 장점을 가지고있다.\n배열 연산자를 통해 일반적인 연산이나 추가 삭제 등이 가능하다.\na = [1, 2, 3] b = [4, 5, 6] print(a + b) # [1, 2, 3, 4, 5, 6] print(a.pop(0)) # 1 print(a.append(4)) # [1, 2, 3, 4] 다만 C의 array 보다는 메모리를 더 많이 필요로 한다는 단점이 있다.\nReference\nhttps://opentutorials.org/module/1335/8677 https://opentutorials.org/module/1335/8636 https://studyingych.tistory.com/35 ","date":"2022-05-11T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181748733-7a45d5ed-1ed3-454f-808f-19f470c19353.png","permalink":"https://heetaek.com/p/array-list/","title":"[자료구조] 배열(Array) 과 리스트(List)"},{"content":"TDD(Test Driven Development) 란? 실패하는 테스트를 만들고, 그 테스트가 통과하는 제품을 만들면 결국은 원하는 기능이 동작하게 된다는 개발방법론이다.\n보통은 개발을 끝내고 난 후 테스트를 한다.\n이것의 순서를 바꾸는 것이 TDD 를 적용하는 것이다.\n특히, Python 같은 동적타입언어는 TDD 가 필수다.\nTDD 개발 주기 Red : 단계에서는 실패하는 테스트 코드를 먼저 작성한다.\nGreen : 단계에서는 테스트 코드를 성공시키기 위한 실제 코드를 작성한다.\nBlue : 단계에서는 중복 코드 제거, 일반화 등의 리팩토링을 수행한다\n중요한 것은 실패하는 테스트 코드를 작성할 때까지 실제 코드를 작성하지 않는 것과, 실패하는 테스트를 통과할 정도의 최소 실제 코드를 작성해야하는 것이다.\n이를 통해 실제 코드에 대해 기대되는 바를 보다 명확하게 정의 함으로써 불필요한 설계를 피할 수 있고, 정확한 요구 사항에 집중할 수 있다.\n일반 개발 방식과 TDD 개발 방식의 비교 일반 개발 방식 보통 개발 방식은 ‘요구사항 분석 → 설계 → 개발 → 테스트 → 배포’의 형태의 개발 주기를 갖는다.\n이러한 방식은 소프트웨어 개발을 느리게 하는 잠재적 위험이 존재한다.\n그 이유는 아래와 같다.\n소비자의 요구사항이 처음부터 명확하지 않을 수 있다. 따라서 처음부터 완벽한 설계는 어렵다. 자체 버그 검출 능력 저하 또는 소스코드의 품질이 저하될 수 있다. 자체 테스트 비용이 증가할 수 있다. 이러한 문제점이 발생되는 이유는 어느 프로젝트든 초기 설계가 완벽하다고 말할 수 없기 때문이다.\n고객의 요구사항 또는 디자인의 오류 등 많은 외부 또는 내부 조건에 의해 재설계하여 점진적으로 완벽한 설계로 나아간다.\n재설계로 인해 개발자는 코드를 삽입, 수정, 삭제하는 과정에서 불필요한 코드가 남거나 중복처 될 가능성이 크다.\n결론적으로 이러한 코드들은 재사용이 어렵고 관리가 어려워서 유지보수를 어렵게 만든다.\nTDD 개발 방식 TDD와 일반적인 개발 방식의 가장 큰 차이점은 테스트 코드를 작성한 뒤에 실제 코드를 작성한다는 것이다.\n디자인(설계) 단계에서 프로그래밍 목적을 반드시 미리 정의해야만 하고, 무엇보다 테스트해야 할지 미리 정의(테스트 케이스 작성)해야만 한다.\n테스트 코드를 작성하는 도중 발생하는 예외 사항(버그 및 수정사항)은 테스트 케이스에 추가하고 설계를 개선한다.\n이후 테스트가 통과된 코드만을 코드 개발 단계에서 실제 코드로 작성한다.\n이러한 반복적인 단계가 진행되면서 자연스럽게 코드의 버그가 줄어들고 소스코드는 간결해진다.\n또한 테스트 케이스 작성으로 인해 자연스럽게 설계가 개선됨으로 재설계 시간이 절감된다.\nTDD 개발방법론에 대한 결론 장점 개발시간이 줄어든다. 보통 처음부터 2개의 코드를 짜야한다 생각하지만 테스트 코드를 거치지 않을시 대략 10 ~ 30% 의 개발시간이 늘어난다. 결함이 줄어든다. 예상치 못했던 상황들에서 벗어날수있다. 유지보수 비용이 낮아진다. 위 세가지만봐도 실무에서는 꼭 필요하다는 생각이 든다.\n단점 자신이 개발하던 방식을 많이 바꿔야한다. 하지만 개발에 대해 아직은 적응?을 하는 단계라 적용을 빨리하고 습득할 수 있을 것 같다.\nReference\nhttps://iwannafullstack.tistory.com/entry/TDD-%EB%9E%80 https://gmlwjd9405.github.io/2018/06/03/agile-tdd.html https://inpa.tistory.com/entry/QA-%F0%9F%93%9A-TDD-%EB%B0%A9%EB%B2%95%EB%A1%A0-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C ","date":"2022-05-10T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181748994-a7779896-1bc3-496b-aba2-b25d196e7e53.png","permalink":"https://heetaek.com/p/tdd/","title":"TDD 는 왜 필요한가?"},{"content":"알고리즘 복잡도 알고리즘 복잡도에는\n시간 복잡도 (알고리즘 실행 속도) 공간 복잡도 (알고리즘이 사용하는 메모리 사이즈) 이 두 가지가 있다.\n이 중에서 가장 중요한 시간 복잡도를 꼭 이해해야한다.\n시간복잡도 코딩을 하다보면 \u0026lsquo;이것보다 더 좋은방법은 없을까?\u0026rsquo; 아니면 \u0026lsquo;이게 최선인가?\u0026rsquo; 라고 고민을 많이 하게된다.\n이러한 고민을 하는게 시간복잡도를 고민한다는 것과 같은 말인것같다.\n시간복잡도에서 가장 영향을 많이 미치는건 반복문이다.\n자동차로 출근하기까지의 과정을 예시로 들어보면\n자동차 문 열기 시동걸기 회사까지 이동 주차 시동끄기 자동차 문 잠그기 가장 많은 시간을 소요하는건 사람마다 다르겠지만 보통 3. 회사까지 이동 일것이다.\n3번과 같이 input 이 커지면 반복문이 알고리즘 수행 시간을 지배하게된다.\n저런 알고리즘을 프로그램화시켜서 만들게 된다면 하드웨어나 운영체제의 영향을 받아 어떤 사람은 결과가 빠르게 나올것이고 어떤 사람은 느리게 나오는 결과가 나온다.\n그래서 알고리즘의 실행 시간을 알 수 있는방법이\n빅오(Big-O) 표기법이다.\nBig-O 표기법 Big-O(빅-오) ⇒ 점근적 상한\n알고리즘 최악의 실행시간을 표시 가장 많이, 일반적으로 사용함 Big-Ω(빅-오메가) ⇒ 점근적 하한\nBig-θ(빅-세타) ⇒ 그 둘의 평균\n시간복잡도는 반복문이 핵심이므로 계산 표기 중 최상, 평균, 최악 중 최악의 시간인 Big-O 를 중점적으로 생각하면 될 것같다. Big-O 는 이 정도의 시간이 걸린다 보단 이 정도 시간까지 걸릴 수 있다 를 고려해야한다. 최선의 경우를 고려했을시 예를 들어 최선의 경우는 1초, 평균적으로 1분 , 최악일 경우 1시간이 걸리는 알고리즘을 구현했고, 최선의 경우를 생각해 알고리즘을 100번 실행했다면 100초가 걸려야 정상인데, 1시간이 걸린다면 어디에서 문제가 발생했는지 로직의 많은 부분을 파악해야하므로 문제를 해결하는데 많은 시간이 소요된다.\n평균의 경우를 고려했을시 평균의 경우는 1분이 걸리는 알고리즘이므로 100번 실행했을시 100분의 시간이 소요될거라 생각했는데, 최악의 경우가 발생하여 더 오래걸린다면 최선의 경우와 같은 고민을 하고 문제 해결에 시간이 소요된다.\n최악의 경우를 고려했을시 위의 최선 과 평균 의 예시를 보다시피 최악 의 경우가 발생하지 않기를 바라면서 코딩을 하는것보다 최악의 경우를 대비 하며 코딩하는것이 맞다고 생각한다. 쉽게 말해 Big-O 는 최악의 경우에도 이 정도의 퍼포먼스는 보장한다라는 것이다.\nBig-O 표기법 종류 O(1) O(log n) O(n) O(n2) O(2n) O(1) O(1) 은 입력 값이 증가하더라도 시간이 늘어나지 않는다.\nex)\ndef test(n): return int(n * (n + 1) / 2) test(3) 결과\n6\n입력 n이 어떻든 간에 반복문이 없기때문에 시간복잡도는 1 이다.\n빅오 표기법으로는 O(1) 입니다.\nO(log n) Big-O표기법중 O(1) 다음으로 빠른 시간 복잡도를 가집니다.\nn 개의 크기 순으로 정렬된 배열에서 특정 값을 찾기 위해 이진 탐색\n이해하기 쉬운 게임으로 비유해 보자면 업다운을 예로 들 수 있습니다. 1~100 중 하나의 숫자를 플레이어1이 고른다 (30을 골랐다고 가정) 50(가운데) 숫자를 제시하면 50보다 작으므로 down을 외친다 1~50중의 하나의 숫자이므로 또다시 경우의 수를 절반으로 줄이기 위해 25를 제시한다 25보다 크므로 up을 외친다 경우의 수를 계속 절반으로 줄여나가며 정답을 찾는다 O(n) O(n) 은 입력 값이 증가함에 따라 시간도 같이 증가하는 것을 의미합니다.\ndef test(n): total = 0 for num in range(1, n + 1): total += num return total test(3) 결과\n6\n입력 n 에 따라 n 번을 반복문을 사용해 더해야합니다.\n따라서, 시간복잡도는 1 빅오 표기법은 O(n) 입니다.\nO(n2) 입력 값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미합니다.\ndef test(li): for n in li: for m in li: return n,m 반복문이 두 번 있으면 O(n2)\n반복문이 세 번 있으면 O(n3)\n\u0026hellip;\n반복문 백 번 있으면 O(n100) 이지만, n 이 커질수록 지수가 주는 영향력이 없어지기 때문에,\n그냥 n2 라고 표기합니다.\nO(2n) Big-O 표기법 중 가장 느린 시간 복잡도를 가지고있습니다.\ndef test(n): if n == 0: return 0 elif n == 1 or n == 2: return 1 else: return fib(n - 1) + fib(n - 2) 재귀 함수를 통해 구현한 피보나치 수열은 O(2n) 의 시간 복잡도를 가지고있습니다.\n위의 사진을 보면 차트가 가파르게 올라가는데 n 의 값이 커지면 시간 복잡도도 같이 증가하기 때문입니다.\n간단한 예시를 들면, 종이를 42번 접으면 두께가 지구에서 달까지 갈 만큼 커진다는 이야기가 있는데 그만한 두께를 가질 수 있는 이유는 매번 접을 때마다 2배로 늘어나기 때문입니다.\nReference\nhttps://psychoria.tistory.com/770 https://blog.chulgil.me/algorithm/ https://data-marketing-bk.tistory.com/27 ","date":"2022-05-08T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181748733-7a45d5ed-1ed3-454f-808f-19f470c19353.png","permalink":"https://heetaek.com/p/algorithm-complexity/","title":"[알고리즘] 시간 복잡도"},{"content":"자료구조 (Data Structure) 자료구조란? 대량의 데이터를 효율적으로 관리할 수 있는 데이터 구조 특정한 상황에 놓인 문제를 해결하는 데에 특화되어있다. 많은 자료구조를 알아두면, 특정 문제를 해결하는 데에 상황에 가장 적합한 자료구조를 빠르게 찾아 데이터를 정리하고 활용하여 해결할 수 있다. 문제해결에 필요한 알고리즘과 밀접한 연관이 있다. 결국은 개발자가 문제해결을 하기 위해 배우는 것이다. 쉽게 말해,\n자료는 도서관의 책들\n구조는 도서관의 책들을 규칙에 따라 정리한 것.\n이러면 조금 이해가 쉬울것같다.\n왜 자료구조를 배워야할까? 데이터는 문자, 숫자, 사진, 소리 등 실생활을 구성하고 있는 모든 값이다. 이 데이터을 이용해 컴퓨터 메모리를 어떻게 효율적으로 사용하며, 실행속도를 빠르고 정확하게 처리를 할 수 있을까에 대해 궁극적인 목표를 두고있다.\n데이터 관리 예시 우편번호 예시\n우편번호의 5자리중 앞 3자리는 시,군, 자치구를 표기, 뒤 2자리는 일련번호로 구성 군대에서의 예시\n군대에서의 XX사단, XX연대, XX연대, XX대대 ~ X소대 XXX 병사 만약 위 처럼 관리가 되지않는다면 군대에있는 모든 병사를 훑어야 할 것이다. 자료구조 분류 ","date":"2022-05-07T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181748733-7a45d5ed-1ed3-454f-808f-19f470c19353.png","permalink":"https://heetaek.com/p/data-structure-algoithm/","title":"[자료구조] 자료구조(Data Structure)란?"},{"content":"컴퓨터 사이언스가 왜 필요했는지? 네이버 부스트코스에서 진행하는 \u0026lsquo;CS50\u0026rsquo; 이라는 강의를 수강했다.\n비전공자인 나에게는 컴퓨터 사이언스에 관한 지식이 필요했다.\n2진법 (binary) 우리가 일상에서 0,1,2,3,4,5,6,7,8,9 라고 표현하는것을 10진법\n컴퓨터는 오직 0, 1 단 두개만을 사용해 데이터를 표현을 한다. 이것을 우리는 2진법이라 부른다.\n예들들어, 우리가 알고있는 10진법의 숫자 13 을 2진법으로 바꾸게된다면\n결과는 1101 이다.\n(\\(2^3=8\\)) = 1\n(\\(2^2=4\\)) = 1\n(\\(2^1=2\\)) = 0\n(\\(2^0=1\\)) = 1\n1 이라고 표시한건 True 라고 생각하면된다.\n고로 \\(8 + 4 + 1 = 13\\) 이 된다.\n여기서 궁금점이 컴퓨터는 엄청난 발전을 이뤄왔는데 지금까지도 2진법을 이용할까?\n2진수를 이용한 컴퓨터가 정확성이 높고, 효율적이기 때문이다.\n3이상의 n 진수를 사용할 경우 전기적 신호는 n가지의 경우로 구분 된다.\n그렇게 되면, 오류 발생량과 소요 시간 및 비용은 증가하게된다.\n따라서, 2진수를 기반으로 컴퓨터를 운영할때 오류를 최소화하고 효율적인 시스템 구축이 가능하다.\n트랜지스터 우리가 현재 쓰고있는 컴퓨터의 CPU 는 트랜지스터로 이루어진 반도체로 만들어졌다. 이 트랜지스터는 0과 1이라는 전기신호로 작동을 한다.\n전압이 높으면 1, 전압이 낮으면 0 이런식으로 열고 닫히고 우리가 흔히아는 Yes or No 혹은 True or False 이다.\n물론 AND 나 OR 같은 논리는 CPU 에 ALU 라는 산술논리장치가 있기에 가능하다.\n아스키코드 (ASCII) 트랜지스터가 on/off 되면서 숫자를 표현했는데,\n그 숫자를 이용해 아스키코드를 통해 문자도 표현이 가능합니다.\n10진수를 통해 표현이 되는데 예시로 A는 65 , B는 66 로 되어있습니다.\n\u0026lt;참고\u0026gt; 이 ASCII 코드로 내 이름인 HEETAEK을 표현해보자면\n\\(H = 72 = 1001000\\)\n\\(E = 69 = 1000101\\)\n\\(E = 69 = 1000101\\)\n\\(T = 84 = 1010100\\)\n\\(A = 65 = 1000001\\)\n\\(E = 69 = 1000101\\)\n\\(K = 75 = 1001011\\)\n위와 같이 표현된다.\n","date":"2022-05-06T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749747-9f7c5bbb-4690-44ac-8e96-15e052779094.png","permalink":"https://heetaek.com/p/cs50-computational-thinking/","title":"[CS] 컴퓨팅 사고"},{"content":"기존에 무언가를 비교할때 is 나 == 을 똑같다 생각하고 많이 쓰고는 했다.\n하지만 똑같지 않았다.\n먼저 결론은,\nis 는 객체를 확인\n== 는 값을 확인\n\u0026gt;\u0026gt;\u0026gt; a = 1 \u0026gt;\u0026gt;\u0026gt; a is 1 True \u0026gt;\u0026gt;\u0026gt; a == 1 True 위의 결과는 당연하다 1 은 boolean 값으로 True 이다.\n반면,\n\u0026gt;\u0026gt;\u0026gt; a = 1995 \u0026gt;\u0026gt;\u0026gt; a is 1995 False \u0026gt;\u0026gt;\u0026gt; a == 1995 True a 라는 변수에 1995 를 넣었을떄는 False 를 반환한다.\nis 는 객체를 비교하고 == 는 값을 비교하기 때문이다.\n\u0026gt;\u0026gt;\u0026gt; id(a) 140307053806736 \u0026gt;\u0026gt;\u0026gt; id(257) 140307053806576 위와 같이 서로의 메모리 주소도 다른것을 볼 수 있다.\n기본중에 기본인것을 모르고 지금까지 하고있었다. 이와같이 is 와 == 을 헷갈리지말자.\n","date":"2022-04-26T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151964846-19a947e0-45be-421d-9515-84a921077aeb.png","permalink":"https://heetaek.com/p/python-is/","title":"[Python] 'is' 와 '==' 의 차이점"},{"content":"1. 프로젝트 1-1. 프로젝트 설명 부트캠프를 시작하고 백엔드에 대한 전반적인 flow 가 다 그려지기도 전에 프로젝트를 시작하게 되었다. 프로젝트명은 \u0026lsquo;배민서바이벌\u0026rsquo; 이다. 기존 배민문방구의 사이트를 클론하며 컨셉을 바꿔서 진행하게 되었다.\n1-2. 팀원 설명 프론트엔드 한신웅 : 네비바 , 장바구니\n주지홍 : 메인페이지, 상품상세페이지\n임채현 : 로그인/회원가입, 마이페이지\n백엔드 최희택 : 로그인 / 회원가입 , 상품관련, 장바구니 1-3. 사용기술 프론트엔드 HTML/CSS JavaScript React 백엔드 Django bcrypt JWT MySQL AWS EC2 AWS RDS 협업툴 Github Trello Slack 프론트개발자에게 API 정의서를 전달하기 위해 Postman 이나 Gitbook 이 있는지 모르고, 구글스프레드 시트로 정리해서 전달했다. 정말 아쉬운 부분이다. API 기능 정의가 제대로 전달 안되어 소통에 어려움이 있어 정말 아쉬운 부분이다.\n2. 완성물 2-1. Nav 로그인 완료 후 유저 닉네임, 포인트, 장바구니 수량 상단에 적용 스크롤 이벤트 선택 된 카테고리 CSS 적용 2-2. 회원가입/로그인페이지 회원가입시 다양한 유효성 검사 (양식검사, 중복검사, 비밀번호 불일치 검사) 검사를 통과하지 못할 경우 입력칸 아래에 경고 문구 출력 양식검사, 중복검사를 모두 통과할 경우 사용가능 출력 경고 문구가 남아있을 시 회원가입 불가 출력 경고 문구가 사라졌을시 회원가입 가능 2-3. 메인페이지 메인페이지 상단 이미지슬라이드 구현 분류 기준 (최신순 / 높은가격순 / 낮은가격순 )에 따른 제품 리스트 렌더링 쿼리스트링을 활용하여 카테고리 페이지 구현 및 페이지네이션 기능 구현 2-4. 상세페이지 인풋창 조건에 따른 수량입력 로그인 상태일 때 장바구니로 구매버튼을 눌렀을때 장바구니로 넘어가도록 구현 비 로그인 상태일 때 장바구니로 구매버튼을 눌렀을때 장바구니로 넘어가도록 구현 제품 상태에 따른 상세페이지 렌더링 화면 변경 2-5. 장바구니 상세페이지에서 유저가 옵션과 수량을 결정한 아이템을 장바구니에 렌더링 ‘옵션 / 수량 변경’ 버튼 클릭시 모달 창이 뜨고 원하는 조건 변경 가능 리스트에서 체크를 통해 아이템 선택 삭제 및 구매 가능 구매 후 구매 완료 페이지로 이동 2-6. 프로젝트 발표 프로젝트 기간동안 정말 즐거웠지만, 마지막 발표날에는 정말 폐인이 된 모습이다.\n3. 회고 백엔드 개발자인 나는 나만 잘하면돼~ 라는 생각을 솔직히 어느정도는 갖고있었다. 막상 프로젝트를 시작하고나니, 나만 잘하면되는게 절대아니였다.\n소통, 협업 등 모든게 합이 잘 맞아야하는게 개발이다.\n내가 이 길이 맞나? 라는 생각이 수백번들었고, 그 순간마다 \u0026lsquo;나는 아직 20살이야 더 잘 할 수있어\u0026rsquo; 긍정적인 생각만하며, 부족한 부분을 공부하며 적용시키고 희열을 느끼고 \u0026lsquo;내가 정말 이 길이 맞구나\u0026rsquo; 라는 생각이 들게끔하였다. 그 결과는 \u0026lsquo;나는 개발자구나\u0026rsquo; 이다.\n이 결과가 나오게끔 도와준건 팀원덕도있다. 백엔드가 혼자였기에 API 를 개발하기에 정말 턱없이 부족한 시간이였지만, 항상 응원해준 우리 프론트 팀원들 덕에 더욱더 긍정적일 수 있었다.\n항구에 정박한 배는 안전하다. 그러나 배는 묶어두려고 만든게 아니다. 아무것도 안하면 실패는 없지만, 개발자는 도전하고 개척하는 존재라 생각한다.\n그런 백엔드 개발자가 되려한다.\n","date":"2022-02-17T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749668-f22414d5-b252-49d0-b9b3-c24b256f57bc.png","permalink":"https://heetaek.com/p/baemin-survival/","title":"[배민서바이벌] 프로젝트 완성 및 회고"},{"content":"Query String 기존에 저는 뷰를 작성하고 특정 URL로 접속해 body에 데이터를 담아 JSON 타입으로 인코딩을 해서 통신을 했습니다. 그러나 클라이언트의 기능이 점점 추가될수록 서버 측에서는 조건에 따라 모든 API를 작성하는 것이 반복적이고 불필요한 작업이 될 수 있습니다.\n이러한 문제점을 해결해주는게 RESTful한 API 작성을 도와주는 Query String 입니다.\nRESTfulAPI 란??\nQuery String 은 ?로 시작해서 \u0026amp;를 통해 여러 데이터를 동시에 전달 가능합니다.\nviews.py\nclass ProductDetailView(View): def get(self, request, product_id): try: product = Product.objects.get(id = product_id) result = { \u0026#39;id\u0026#39; : product.id, \u0026#39;name\u0026#39; : product.name, \u0026#39;shipping\u0026#39; : product.shipping, \u0026#39;price\u0026#39; : product.price, \u0026#39;is_green\u0026#39; : product.is_green, \u0026#39;is_sale\u0026#39; : product.is_sale, \u0026#39;category_id\u0026#39; : product.category_id, \u0026#39;stock\u0026#39; : product.stock, \u0026#39;discount_price\u0026#39; : product.discount_price, \u0026#39;image\u0026#39; : product.image_set.all()[0].img_url } return JsonResponse({\u0026#39;result\u0026#39;: result}, status = 200) urls.py\nurlpatterns = [ path(\u0026#34;/\u0026lt;int:product_id\u0026gt;\u0026#34;,ProductDetailView.as_view()) ] 위의 코드는 기존의 상품을 가져오는 뷰\nhttp://127.0.0.1/products/7\n라고 입력을 하면 product_id 의 7번 상품을 조회해서 정보를 JSON 타입으로 주었습니다.\n이번에는 쿼리스트링을 적용해 볼까요?\nviews.py\nclass ProductDetailView(View): def get(self, request): try: product_id = request.GET.get(\u0026#39;id\u0026#39;) products = Product.objects.filter(id = product_id).values() products = list(products) return JsonResponse({\u0026#39;result\u0026#39;: products}, status = 200) urls.py\nurlpatterns = [ path(\u0026#34;\u0026#34;,ProductDetailView.as_view()) ] request.GET.get 으로 id 7번 아이템을 가져와서 모든 정보를 가져오라는 뜻입니다.\n그래서 입력을 http://127.0.0.1:8000/products?id=7 이렇게 했더니\n똑같이 정상적으로 출력이 되는 것을 확인하실 수 있습니다.\n아직까지도 난해한 부분이라 계속 응용을 해봐야할것같습니다.\n","date":"2022-02-06T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/152298321-8698e3ad-b0d5-4ebb-b892-b8969f517540.png","permalink":"https://heetaek.com/p/django-query-string/","title":"[Django] Query String 쿼리스트링"},{"content":"view 를 작성하다 클라이언트에 json 데이터를 반환을 해주다보니 from django.http import JsonResponse JsonResponse 객체를 끌어다와서 쓰기도합니다.\n근데 반환을 해주는 함수의 인자에는 필요하지도 않은 request 인자를 다들 포함시키길래 저도 지금껏 계속 쓰긴했습니다.\n그래서 지우고 테스트해보니\nTypeError : get() takes 1 positional argument but 2 were given 과 함께 500 에러를 주네요.\n그럼 request 가 필요하다는거겠죠.\n알아보기위해 django 최상위 제네릭 뷰 클래스에서 알아보겠습니다.\nGeneric View 란 반복적으로 사용되는 공통 부분을 패턴화해서 쉽게 추상화 해둔 것입니다. class View: \u0026#34;\u0026#34;\u0026#34; Intentionally simple parent class for all views. Only implements dispatch-by-method and simple sanity checking. \u0026#34;\u0026#34;\u0026#34; http_method_names = [\u0026#39;get\u0026#39;, \u0026#39;post\u0026#39;, \u0026#39;put\u0026#39;, \u0026#39;patch\u0026#39;, \u0026#39;delete\u0026#39;, \u0026#39;head\u0026#39;, \u0026#39;options\u0026#39;, \u0026#39;trace\u0026#39;] def __init__(self, **kwargs): \u0026#34;\u0026#34;\u0026#34; Constructor. Called in the URLconf; can contain helpful extra keyword arguments, and other things. \u0026#34;\u0026#34;\u0026#34; # Go through keyword arguments, and either save their values to our # instance, or raise an error. for key, value in kwargs.items(): setattr(self, key, value) @classonlymethod def as_view(cls, **initkwargs): \u0026#34;\u0026#34;\u0026#34;Main entry point for a request-response process.\u0026#34;\u0026#34;\u0026#34; for key in initkwargs: if key in cls.http_method_names: raise TypeError( \u0026#39;The method name %s is not accepted as a keyword argument \u0026#39; \u0026#39;to %s().\u0026#39; % (key, cls.__name__) ) if not hasattr(cls, key): raise TypeError(\u0026#34;%s() received an invalid keyword %r. as_view \u0026#34; \u0026#34;only accepts arguments that are already \u0026#34; \u0026#34;attributes of the class.\u0026#34; % (cls.__name__, key)) def dispatch(self, request, *args, **kwargs): # Try to dispatch to the right method; if a method doesn\u0026#39;t exist, # defer to the error handler. Also defer to the error handler if the # request method isn\u0026#39;t on the approved list. if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed return handler(request, *args, **kwargs) as_view 는 뷰를 하나 만들어서 이것을 return 해주는 역할입니다.\n문제의 dispatch 는 as_view 메소드 내부에서 호출됩니다. request 메소드가 정의된 http_method_names 에 해당되면 request 에서 가져오게됩니다.\n공식문서 를 참고해봐도 JsonResponse 는 HttpRequest 의 하위 클래스네요\n이래서 인자에 request 가 포함되어있나봅니다.\nGeneric View 를 보다보니 공부가 많이되네요.\n앞으로 Generic View 에 대해 더 깊이 다뤄보고 블로그 글 작성하겠습니다.\n","date":"2022-02-03T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/152298321-8698e3ad-b0d5-4ebb-b892-b8969f517540.png","permalink":"https://heetaek.com/p/django-why-need-request/","title":"[Django] JsonResponse를 쓰는데 왜 request 가 필요할까"},{"content":"컴프리헨션 (Comprehension) 이란? 컴프리헨션이란 뭔가를 내포 , 압축의 뜻을 담고있습니다. 직관적으로 리스트를 생성하는 방법입니다. 컴프리헨션은 파이썬의 자료형 (list,dict,set) 에 대해 사용 할 수 있기 때문에 기본적인 자료형에 대해서는 공부를 하셔야합니다. 이번 블로그는 대표적인 리스트 컴프리헨션에 대해 써볼겁니다.\n리스트 컴프리헨션 (List Comprehension) 반복문 일반적인 반복문으로 리스트 생성 a = [] for i in range(10): a.append(i) 리스트 컴프리헨션 [i for i in range(10)] 같은 결과가 출력됩니다.\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n좀 더 응용해볼까요? 재밌네요\n[i * 5 for i in range(10)] 기존의 i 에 5가 곱해져서\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]\n라는 결과가 출력됐습니다.\n조금만 생각하면 정말 쉽다는겁니다.\n일반적인 리스트 생성할때와 리스트 컴프리헨션을 참고 해보시면\na 의 빈 리스트가 컴프리헨션 양 옆에 달라 붙었습니다.\n반복문은 위의 이미지와 같이 리스트 내부에 작성합니다.\n쉽죠? 직접 에디터 키고 해보시는걸 추천드립니다.\nif 조건문 위에서 살펴본것은 반복문을 사용한 컴프리헨션입니다. 반복문 이외에도 조건문을 활용해볼수있습니다. 컴프리헨션을 쓰다 보면 이 조건문을 쓰는 게 매우 편리합니다. if문만 쓸 때는 오른쪽에, if else문을 쓸때는 왼쪽에 씁니다.\n[i for i in range(10) if i % 2 == 0] 결과 [0, 2, 4, 6, 8]\nif else 조건문 [i if i % 2 == 0 else \u0026#39;odd\u0026#39; for i in range(10)] 결과 [0, 'odd', 2, 'odd', 4, 'odd', 6, 'odd', 8, 'odd']\n위의 반복문에 조건문만 들어간거라 생각하시면 간단합니다.\n","date":"2022-02-02T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151964846-19a947e0-45be-421d-9515-84a921077aeb.png","permalink":"https://heetaek.com/p/python-list-comprehension/","title":"[Python] 리스트 컴프리헨션(List Comprehension)"},{"content":"\nfilter 뷰를 작성하다보면 filter 를 사용해 데이터를 조회해야할때가 많습니다.\n전에 썻던 get() 과 filter() 비교글 을 보셨으면 조금 더 이해가 잘 되실겁니다.\n계속 filter 에 대해 쓰는 이유는 중요하기도 하고 저도 배워야하기 때문에..\nexact exact 는 정확히 일치하는 데이터를 찾습니다.\nProduct.objects.get(id__exact = 14) Product 라는 객체에 id 가 14번인 친구를 찾으라는 거겠죠?\niexact iexact 는 대소문자를 구분하지않고 정확히 일치하는 데이터를 찾습니다.\nProduct.objects.get(name__iexact = \u0026#39;k9 tank\u0026#39;) 마찬가지로 Product 라는 객체에 name 이 k9 tank 라는 친구를 찾아오라는 겁니다.\ncontains contains 는 포함하고있는 문자열을 찾습니다.\nUsers.objects.filter(name__contains = \u0026#39;희택\u0026#39;) 위의 코드는 희택 이라는 친구를 가져오라는 겁니다.\nicontains icontains 는 대소문자를 구분하지않고 포함하고있는 문자열을 찾습니다. 사실 왠만하면 저는 icontains 를 쓸텐데..나중에 써보고 어떤게 더 좋은지 블로그에 또 써보겠습니다.\nUser.objects.filter(job__icontains = \u0026#39;bus Driver\u0026#39;) 이렇게 하면 버스 기사님의 정보를 다 가져올수있겠죠.\nin in 은 여러 조건을 포함할 경우 사용합니다. list , tuple 등 iterable 한 객체를 가져올수있습니다.\nUsers.objects.filter(id__in=[1, 3, 4]) Users.objects.filter(name__in=[\u0026#39;최희택\u0026#39;,\u0026#39;이정재\u0026#39;,\u0026#39;공유\u0026#39;]) gt , lt , gte , lte gt : \u0026gt; lt : \u0026lt; gte : \u0026gt;= lte : \u0026lt;= 부등호를 사용할수있습니다.\nUsers.objects.filter(id__gt=4) startswith , istartswith startswith : 조건으로 시작하는 문자열 검색 istartswith: startswith 을 대소문자 구분없이 검색 Products.objects.filter(name__startswith=\u0026#34;gun\u0026#34;) endswith , iendswith endswith : 조건으로 끝나는 문자열 검색 iendswith : endswith 를 대소문자 구분없이 검색 Products.objects.filter(name__startswith=\u0026#34;tank\u0026#34;) range range 는 범위에 해당하는 object를 찾습니다.\nimport datetime start_date = datetime.date(2022, 1, 1) end_date = datetime.date(2022, 1, 31) Products.objects.filter(created_date__range=(start_date, end_date)) ","date":"2022-01-31T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151730971-5125d3b2-552d-4673-9d52-839d685f2593.png","permalink":"https://heetaek.com/p/django-queryset-filter/","title":"[Django] QuerySet filter 제대로 알아보자"},{"content":"정규식으로 이메일과 패스워드 유효성 검증 후 , 매치가 되지않으면 ValidationError 를 출력하게끔 해놓았습니다. 근데 프론트에서 일부러 틀리게 집어넣어봐도 오류내용도 안뜬다고 해서 직접 포스트맨으로 테스트를 해보았는데 역시나 ValidationError 를 처리를 못 해주고있었습니다.\n터미널에서도 ValidationError 와 내부서버오류인 500코드만 띄워주네요.\n처음에는 raise 로 에러를 주면 그게 콘솔에 찍히는 줄 알았습니다.\n바로 구글링을 하여 찾아보고, 참고 : https://stackoverflow.com/questions/10307996/python-how-to-print-the-message-inside-validationerror\nValidationError 의 메시지를 출력해주게끔 똑같이 코드를 넣어보니 정상적으로 프론트에서도 콘솔에 찍히는걸 확인할수있었습니다. 포스트맨에서도 정상적으로 json 데이터를 받아오는걸 확인할수있습니다. 이제 터미널에서도 이쁘게 에러코드가 확인됩니다.\n저만 몰랐던 에러처리방법..이렇게 배우고 알아갑니다.\n","date":"2022-01-30T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151670116-ea498b04-6e79-4bd1-aaae-ad54eeb7eb5b.png","permalink":"https://heetaek.com/p/django-raise/","title":"[Django] raise error 메시지를 json데이터로 출력하는 방법"},{"content":"REST? 우선 REST 에 대해서 알아야 합니다. REST 란 웹에 존재하는 자원에 대해 고유한 URI 부여하는 방법입니다. 현재 가장 널리 알려져 사용되고있는 기술이기도 합니다.\nRESTfulAPI 는 앞서말한 REST의 규칙을 지키며 API 를 개발하는걸 뜻합니다.\n간단한 예시를 들어드리자면,\n구글이나 네이버를 잠깐 검색해봐도 주소창에는 뭔가의 규칙에 의해 나와있습니다. 규칙성은 없지만 구글검색엔진의 백엔드 API 네이밍 룰을 따르겠죠?\n장점 : RESTful API는 그 자체만으로도 API의 목적이 쉽게 이해가 됩니다. 단점 : 위의 구글 예시와같이 표준규약이 없어서 안티패턴으로 작성되는 경우가 흔합니다. RESTfulAPI 위에서 REST 에 대해 배워보았으니 RESTfulAPI 가 뭔지 알아야겠죠 REST 라는 원리를 이용하여 API 를 제작하는것을 RESTfulAPI 라 합니다. 모든 CRUD 기능을 POST로 처리 하는 API 혹은 URI 규칙을 올바르게 지키지 않은 API는 REST API를 사용하였지만 RESTful 하지 못한 시스템이라고 할 수 있습니다.\nREST API 설계 가이드 이제 REST 와 RESTfulAPI 가 뭔지 알았으니, REST API 작성 규칙을 알아보고 RESTful 한 API 설계 방법을 알아봅시다.\nREST API 설계 가이드 - 1 REST API 설계 시 가장 중요한 항목은 다음의 2가지로 요약할 수 있습니다.\nURI는 정보의 자원을 표현해야 한다. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다. HTTP Method 역할 GET GET를 통해 해당 리소스를 조회합니다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다. POST POST를 통해 해당 URI를 요청하면 리소스를 생성합니다. PUT PUT를 통해 해당 리소스를 수정합니다. DELETE DELETE를 통해 리소스를 삭제합니다. REST API 설계 가이드 - 2 URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 합니다. Bad Example : https://heetaek.com/Learning Good Example : https://heetaek.com/learn 2. 마지막에 슬래시 ( / )를 포함하지 않습니다.\nBad Example : https://heetaek.com/post/ Good Example : https://heetaek.com/post 3. 언더바( _ ) 대신 하이폰( - )을 사용합니다.\nBad Example : https://heetaek.com/handsome_heetaek Good Example : https://heetaek.com/handsome-heetaek 4. 파일확장자는 URI에 포함하지 않습니다.\nBad Example : https://heetaek.com/heetaek.png Good Example : https://cidk.xyz/photo 5. 행위를 포함하지 않습니다.\nBad Example : https://heetaek.com/delete-post/3 Good Example : https://heetaek.com/post/3 Reference: https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html\n","date":"2022-01-29T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151964947-48b18c99-efb0-44fc-b442-ada8801e7a96.png","permalink":"https://heetaek.com/p/rest-api/","title":"[Network] REST API란?"},{"content":"참조 (Foreign Key) 정참조라하기도 하고 Foreign Key 를 가지고있는 테이블을 가져올 수 있습니다.\n위와 같은 모델이 있다고 가정할때\nclass Movie(models.Model): # 영화 actor [2] = models.ForeignKey(\u0026#39;Actor\u0026#39;, on_delete = CASCADE) title = models.CharField(max_length=100) . . . class Actor(models.Model): # 영화배우 name [3] = models.CharField(max_length=100) age = models.CharField(max_length=30) . . . 영화(Movie) 라는 모델에서 영화배우(Actor)를 불러들이는 것을 \u0026lsquo;참조\u0026rsquo; 라 합니다.\na = Movie.objects.get(id = 1) [1] [1] [2] [3] a.actor.name \u0026gt;\u0026gt;\u0026gt; \u0026#39;이정재\u0026#39; 반대로 Actor 객체는 Movie 를 역참조 하고 있으므로 바로 접근이 불가능합니다.\n역참조 관계에 있을때는 아래의 역참조 세션에서 확인해봅시다.\n역참조 (related_name) 정참조하고있는 클래스에서 어떤 명칭으로 거꾸로 호출당할지를 정해주는 이름입니다,\n정참조했을때와 같은 모델인데 Movie 클래스의 actor 에 related_name = 'my_related' 가 생겼습니다.\nclass Movie(models.Model): # 영화 actor = models.ForeignKey(\u0026#39;Actor\u0026#39;, on_delete = CASCADE, related_name = \u0026#39;my_related\u0026#39;) title = models.CharField(max_length=100) . . . class Actor(models.Model): # 영화배우 name = models.CharField(max_length=100) age = models.CharField(max_length=30) . . . Actor 객체의 인스턴스와 연결되어있는 Movie 객체를 불러올때 my_related 라는 이름을 부르기 위해서입니다.\nb = Actor.objects.get(id = 1) b.my_related.all() \u0026gt;\u0026gt;\u0026gt; \u0026lt;QuerySet[\u0026lt;Object Movie Object(1)\u0026gt;, \u0026lt;Object Movie Object(2)\u0026gt;]\u0026gt; 이런식으로 진행됩니다.\n역참조가 꼭 필요할때 눈치채셨을분들도 계시겠지만\nclass Movie(models.Model): # 영화 actor = models.ForeignKey(\u0026#39;Actor\u0026#39;, on_delete = CASCADE) actor2 = models.ForeignKey(\u0026#39;Actor\u0026#39;, on_delete = CASCADE) . . 한 클래스에서 서로 다른 두 컬럼이 같은 테이블을 참조하는 경우\nrelated_name 으로 구분해서 호출할 수 있게끔 작성해줍니다.\nclass Movie(models.Model): # 영화 actor = models.ForeignKey(\u0026#39;Actor\u0026#39;, on_delete = CASCADE, related_name = \u0026#39;my_related\u0026#39;) actor2 = models.ForeignKey(\u0026#39;Actor\u0026#39;, on_delete = CASCADE, related_name = \u0026#39;your_related\u0026#39;) . . 머리가 나빠서 이해하는데 꽤 오래걸렸습니다 .\n","date":"2022-01-22T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/150625177-c20926d0-c57a-4ebd-81ef-ae67694fc94b.png","permalink":"https://heetaek.com/p/django-related-name/","title":"[Django] 참조(Foreign Key) 역참조(related_name)"},{"content":"\n시작 먼저 python console 을 실행해줍니다. 프로젝트 manage.py 가 있는 디렉토리에서 python manage.py shell 을 입력해주면 콘솔이 실행됩니다. 저는 models 에 User 라는 클래스를 만들어주어서\n임포트 해주겠습니다.\nget() get() 은 객체 하나만 반환을 해줍니다. 그래서 get() 의 경우는 unique 한 값을 가지고 검색을 하는것이 좋습니다.\n예를들어 id 가 1번값을 가지고있는 데이터를 가지고오고싶을때는 아래의 사진처럼 User.objects.get(id=1) 이런식으로 가져오시면 됩니다. 쿼리에 맞는 결과가 없을시에는\nDoesNotExist 라는 오류가 발생하게됩니다.\n왜냐하면 제 데이터베이스에는 id가 1번인 데이터가 없기때문입니다.\n정상적으로 데이터를 가져오면\noutput 으로 어떠한 객체를 가져왔는지 \u0026lt;User: User object (53)\u0026gt; 이라고 표시됩니다.\nfilter() filter() 를 이용해 검색을 하면 여러개의 객체를 포함하는 QuerySet 을 반환해줍니다. filter()의 특징은 특정 조건을 만족하는 객체를 검색할때 사용합니다. QuerySet 이란 DB 에서 전달받은 객체들의 모음(List) 입니다. DB에서는 row 에 해당합니다.\n예를 들어, asdasd 라는 이름을 가진 사람을 찾고싶어서\nUser.objects.filter(name=\u0026quot;asdasd\u0026quot;)\nfilter 를 사용해 찾아보았습니다.\nQuerySet 으로 59번과 61번 객체를 가져왔습니다.\n제 테이블에는 59, 61번에 asdasd 라는 동명이인이 있기에 두개의 객체가 반환이 됐던겁니다.\n이런식으로 shell 을 직접 두드려보면서 확인하시면 훨씬 쉽게 접근할수있습니다.\n","date":"2022-01-20T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151730971-5125d3b2-552d-4673-9d52-839d685f2593.png","permalink":"https://heetaek.com/p/django-orm-get-filter/","title":"[Django] ORM get(), filter() 비교"},{"content":"데코레이터(decorator)란? 함수 앞뒤에 기능을 추가해서 손쉽게 함수를 활용할 수 있는 기법 클로저 (clousure)를 활용 함수 위에 @ 붙어있는 모습이 데코레이터입니다. 특이하죠? 그래도 알아두어야 나중에 이러한 코드를 볼때 이해할수있습니다.\n데코레이터 활용 @decorator_func def function(): print(\u0026#39;@붙은게 데코레이터\u0026#39;) ex) 일반적인 함수\ndef login(): print(\u0026#34;희택님이 로그인하셨습니다.\u0026#34;) login() 희택님이 로그인하셨습니다. 이게 일반적인 함수입니다.\nex) 데코레이터를 붙인 함수\n# 데코레이터 함수 def decorator_func(func): def wrapper(): print(\u0026#39;나는 데코레이터\u0026#39;) func() return wrapper # 일반함수에 데코레이터를 붙힌 함수 @decorator_func def login(): print(\u0026#39;희택님이 로그인하셨습니다.\u0026#39;) login() 나는 데코레이터 희택님이 로그인하셨습니다. 클로저를 이용한 데코레이터 # 데코레이터 함수 정의 def decorator_func(func): def wrapper(): print(\u0026#39;나는 데코레이터\u0026#39;) func() return wrapper # 데코레이터를 줄 함수 def login(): print(\u0026#39;희택님이 로그인하셨습니다.\u0026#39;) login() 희택님이 로그인하셨습니다. 클로저 활용\ndeco_func = decorator_func(login) deco_func() 나는 데코레이터 희택님이 로그인하셨습니다. 간단하죠?\n","date":"2022-01-05T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151964846-19a947e0-45be-421d-9515-84a921077aeb.png","permalink":"https://heetaek.com/p/python-decorator/","title":"[Python] 데코레이터(Decorator)와 클로저(Clousure) 활용"},{"content":"세트(Set) 와 딕셔너리(Dictonary)의 차이 딕셔너리는 짧게 dict 라 칭하겠습니다.\n먼저 set 와 dict 의 공통점은 {} 중괄호를 쓴다는 점 입니다.\n비슷하다고 생각하실수도있는데\n제일 큰 차이는 dict 는 {\u0026quot;key\u0026quot; : \u0026quot;value\u0026quot; , \u0026quot;이름\u0026quot; : \u0026quot;최희택\u0026quot;, \u0026quot;나이\u0026quot; : 28} 이런식으로 key 와 value 값을 가질수있고, set 는 key 와 value 가 없이 {\u0026quot;최희택\u0026quot;,\u0026quot;바보\u0026quot;,28,23} 이렇게 값만 가질수있습니다. dict 는 key 값은 변경할수없고, value값만 변경이 가능합니다. set는 변경이 가능한 리스트형입니다. 리스트(List) 와 튜플(Tuple)의 차이 list 는 대괄호 [] tuple 은 소괄호를 사용 () list 는 값을 변경 ,추가, 삭제가 가능하고 tuple 은 불가능 (다만 간단하게 수정하지않아도 되는 데이터는 메모리를 적게 사용하는 tuple 을 사용하는게 유리) ","date":"2022-01-04T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151964846-19a947e0-45be-421d-9515-84a921077aeb.png","permalink":"https://heetaek.com/p/python-list-set-dict/","title":"[Python] 세트(Set) 와 딕셔너리(Dictonary) 차이, 리스트(List) 와 튜플(Tuple) 의 차이"},{"content":"클로저에 대해. 함수와 해당 함수가 가지고있는 데이터를 복사, 저장해서 별도 함수로 사용 처음에 보면 이해하기가 어려움 제곱(power)로 예시 중간에 있는 closure_power1 , closure_power2 , closure_power3 가 closure 입니다.\ndef calc_power(x): def power(y): return x ** y return power closure_power1 = calc_power(2) closure_power2 = calc_power(3) closure_power3 = calc_power(4) print(closure_power1(1)) print(closure_power2(2)) print(closure_power3(3)) 결과\n2 9 64 사실 봐도 이해가 안되니 다른 쉬운 예시로 이해해봅시다.\ndef outer_func(num): def inner_func(): print(num) return inner_func closure_func = outer_func(58) closure_func() 결과는? 58 입니다.\nclosure_func = outer_func(58) 에서 outer_func 함수는 호출 종료 closure_func() 은 결국 inner_func 함수를 호출 outer_func(58) 호출 종료시 num 값은 없어졌으나, closure_func()에서 inner_func이 호출되면서 이전의 num값(58)을 사용함 그럼 closure 는 언제 사용하나요?\n제공해야할 기능이 적은경우 , closure 를 사용 반대로 제공해야할 기능이 많은 경우 , class 를 사용하여 구현 ","date":"2022-01-04T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151964846-19a947e0-45be-421d-9515-84a921077aeb.png","permalink":"https://heetaek.com/p/python-closure/","title":"[Python] 클로저(Closure)"},{"content":"Git 이 왜 필요한가요? 예를 들어 자동차를 만든다할때 \u0026lsquo;바퀴\u0026rsquo;, \u0026lsquo;엔진\u0026rsquo; , \u0026lsquo;문짝\u0026rsquo; , \u0026lsquo;시트\u0026rsquo; 등등 세분화하여 어떻게 제작이 되었는지 세세하게 기록을 할 수 있는 프로그램입니다. 치명적인 실수를 했을시에 과거로 되돌아가서 수정을 할 수도 있습니다. VCS(Version Control System) 버전 관리 시스템으로 역할을 나눠 협업을 할 수 있습니다. 처음에는 난해하지만 이해하려하지말고 개인 레파지토리를 생성후 아무 파일이나 올려보시면서 연습하시는걸 추천드립니다. 특히나 개발자에게는 필수인 git 입니다. Git 시작하기 git init\n작업중인 폴더에 git init 명령어를 입력하면 .git 이라는 숨겨진폴더가 생성되고, CCTV 가 하나 설치되서 그 폴더에서 무엇을 하는지 지켜본다고 보시면 편하다다.\nGit branch 생성 branch는 나뭇가지입니다. 그럼 기둥은 뭔가요? 처음 생성될때 master 브랜치가 기둥이라 생각하시면됩니다. 요즘은 master 대신 main 이라고 많이 생성합니다. 그 이유는 master 가 노예제도의 주인님을 연상케 한다해서 main 을 사용한다하니 그렇게 사용해주도록 합시다. Git branch 생성방법 git branch -M main\n-M 옵션은 브랜치를 rename 하는 옵션입니다. 위에도 설명드렸다시피 master 를 안쓴다했으니 저희는 main 으로 변경하겠습니다.\n생성이 완료되면 git branch 라는 명령어로 확인할수있습니다.\nmaster 에서 main 으로 변경된걸 확인할수있습니다.\nFeature branch 생성방법 Feature branch 란 게임에서 많이 보셨을것같은데 베타 , 얼리액세스 , ver1 , ver2 등등의 네이밍으로 버전을 관리합니다. main branch는 실제 서비스 되고있는 branch 이고 지금 만들 feature branch 는 기능을 업데이트하는 버전관리 branch 라 생각하시면 편합니다. 방금 저희는 main 이란 기둥을 만들었습니다. feature branch 만드는법도 간단합니다.\n예를들어 로그인 기능을 개발하고싶으면 git branch feature/login\n회원가입 기능을 개발하고싶으면 git branch feature/signup\n이런식으로 branch 를 생성하시면 됩니다.\nbranch 이동 및 삭제 branch 를 이동하고싶을땐 git checkout {이동하고싶은 branch 명}\nex) main \u0026ndash;\u0026gt; feature/login git check feature/login\nbranch 를 삭제하고싶을땐\ngit branch -d {삭제하고싶은 branch 명}\nex) login branch 를 삭제하고싶을때\ngit branch -d feature/login\n삭제가 잘되었는지 확인\ngit branch\nGit commit commit 이란? 자신이 한 작업의 기록을 남기고 그 기록물에 메시지를 남기는 작업입니다. 다만 주의하실점은 commit 메시지를 작성할때는 일관성있게 작성해야합니다.\n1. Commit Type feat : 새로운 기능 추가 fix : 버그 수정, 기능 수정 docs : 문서 수정 refactor : 코드 리팩토링 (변수명 수정 등) test : 테스트 코드, 리팩토링 테스트 코드 추가 style : 코드 스타일 변경, 코드 자체 변경이 없는 경우 remove : 파일 또는 코드, 리소스 제거 resource : 이미지 리소스, prefab 등의 코드와 상관없는 리소스 추가 2.Commit 주제 제목은 50자를 넘기지 않고, 대문자로 작성하고 마침표를 붙이지 않습니다. ex) 이런식으로 커밋 메시지를 작성하시면됩니다.\nfeat : Add bcrypt feature feat : Add user models fix : Fix type in models remove : Remove white space 나쁜 예시\ntest 수정1 수정2 fix error 다시 다시 push 메시지를 보고 무엇을 했는지 알 수 없게 메시지를 작성하면 적절하지않습니다.\n3. Commit 내용변경 예를들어 commit 을 했는데 feat : Add my featuressss 오타가 나있다면? 당황스럽겠죠\n그럴때 commit 내용을 수정할수있는 명령어인 git commit --amend 를 입력하면 수정할수있습니다. 참고로 터미널로 git 을 사용하신다면 vim 에디터로 수정해야합니다. (제 맥북은 그렇게 합니다.)\nGithub(원격저장소) 에 push 로컬(Local) 에서 작업을 끝내셨으면 원격(Remote) 저장소에 올려야겠죠 github 에 접속하셔서 레파지토리를 생성하시면 위의 이미지처럼 나옵니다. 하나하나 따라하셔도 상관없지만 저희는 README.md 파일만 추가하는게 아니라 작업한 모든 파일을 추가할거기에 git add -A 나 git add . 명령어로 프로젝트 폴더에 수정한 파일이나 추가한 파일들을 추가해줍니다.\n이후 , 배웠던 commit 메시지를 남겨주시고\n브랜치를 생성해줍니다.\ngit remote add origin https://github.com/sosolyht/test.git\norigin 은 origin 이라는 이름으로 원격저장소가 등록되었다는 의미입니다.\n이후 git push -u origin main 명령어를 입력하시면\ngithub 에 push 가 된걸 확인하실수있습니다.\n","date":"2022-01-02T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151965003-3811163e-5f5d-4f16-a634-e617c786e345.png","permalink":"https://heetaek.com/p/git-basic/","title":"[Git] 기초적인 사용방법"},{"content":"default value parameter를 non-default value parameter 앞에 정의 하면 안 되는 이유 non-default value parameter 는 정해져있지않은 인자 타입입니다. 가장 흔하게 쓰는 타입입니다. 함수를 호출할때 인자를 순서대로 넣어주어야합니다.\n아래의 예시로 name , age 를 호출하기 위해선 heetaek 이란 함수에 순차적으로 name = \u0026quot;최희택\u0026quot; , age = 28 이 될 수 있도록 집어넣어주니\ndef heetaek(name,age): print(name,age) return name, age heetaek(\u0026#34;최희택\u0026#34;, 28) 결과는\n최희택 28 이라고 출력 됩니다.\n그에 반해 deault value parameter 는 미리 정해진 인자값을 넣어줍니다,\n예시\ndef heetaek(name, age=28): print(name, age) return name, age heetaek(\u0026#34;최희택\u0026#34;) 미리 age 라는 인자에 제 나이인 28 을 넣어주고 함수호출할때 name 만 넣어주니 정상적으로 최희택 28 을 반환해주는것을 볼 수 있습니다.\n앞에 제목을 보셨다시피 defaut value 를 왜 앞에 정의하면 안되는지 느낌이 오시지않나요?\n만약 age 에 있는 28 을 빼고 name = \u0026quot;최희택\u0026quot; 이라고 써져있었으면\nSyntaxError: non-default argument follows default argument 라고 오류가 발생하게 됩니다.\n앞에 기본값을 정해버리면 뒤에있는 인자는 아무런 값을 할당받지 못해서 오류가 발생하는겁니다.\nFile \u0026#34;/Users/ht/Desktop/Python/test.py\u0026#34;, line 1 def heetaek(name=\u0026#34;최희택\u0026#34;, age): ^^^ SyntaxError: non-default argument follows default argument 가변인수(*args) 와 위치인수 *args 란 언제 변할지 모르는 가변 인자입니다 아래의 예시는 틀린 예시입니다. 아래의 예시 그대로 실행하게되면 TypeError: func_param_with_var_args() missing 1 required keyword-only argument: 'age' 라는 에러가 발생하게됩니다. age 라는 인자를 찾지 못했다는겁니다.\ndef func_param_with_var_args(name, *args, age): print(\u0026#34;name=\u0026#34;,end=\u0026#34;\u0026#34;), print(name) print(\u0026#34;args=\u0026#34;,end=\u0026#34;\u0026#34;), print(args) print(\u0026#34;age=\u0026#34;,end=\u0026#34;\u0026#34;), print(age) func_param_with_var_args(\u0026#34;정우성\u0026#34;, \u0026#34;01012341234\u0026#34;, \u0026#34;seoul\u0026#34;, 20) 그러면 *args 를 age 뒤로 넣고 실행해보겠습니다.\ndef func_param_with_var_args(name, age, *args): print(\u0026#34;name=\u0026#34;,end=\u0026#34;\u0026#34;), print(name) print(\u0026#34;args=\u0026#34;,end=\u0026#34;\u0026#34;), print(args) print(\u0026#34;age=\u0026#34;,end=\u0026#34;\u0026#34;), print(age) func_param_with_var_args(\u0026#34;정우성\u0026#34;, 20, \u0026#34;01012341234\u0026#34;, \u0026#34;seoul\u0026#34;) 인자의 순서에 맞게 name = \u0026quot;정우성\u0026quot; , age = 20 , 나머지 args 에는 args = \u0026quot;01012341234\u0026quot;, \u0026quot;seoul\u0026quot; 가 제대로 호출할수있도록 수정해주었습니다.\n결과는\nname=정우성 args=('01012341234', 'seoul') age=20\n정상적으로 원하던 값이 출력되었네요.\n이와 같이 가변인수는 기존의 인자가 먼저 출력될수있게끔 하고 이후 가변인자가 출력할수있게 순서를 정확히 배치하는것이 중요합니다.\n가변 키워드 인수(**kwargs) 아래의 예시를 그대로 실행하면 def func_param_with_kwargs(name, age, **kwargs, address=0): ^ SyntaxError: invalid syntax 이와 같은 오류가 발생하게됩니다.\n가변인수(*args) 와 위치인수를 보셨으면 아시겠지만 의도와 위치 선정이 중요합니다.\n아래의 코드의 의도는 mobile 에다가 01012341234 를 넣고 address 에는 seoul 을 넣고싶은 의도가 보입니다.\n하지만 name,age 이후에는 가변 키워드 인수가 address 앞에 있어 호출 시 mobile 이 들어가야 하는지 address=\u0026quot;seoul 이 들어가야하는지 모르기때문에 오류가 발생합니다.\ndef func_param_with_kwargs(name, age, **kwargs, address=0): print(\u0026#34;name=\u0026#34;,end=\u0026#34;\u0026#34;), print(name) print(\u0026#34;age=\u0026#34;,end=\u0026#34;\u0026#34;), print(age) print(\u0026#34;kwargs=\u0026#34;,end=\u0026#34;\u0026#34;), print(kwargs) print(\u0026#34;address=\u0026#34;,end=\u0026#34;\u0026#34;), print(address) func_param_with_kwargs(\u0026#34;정우성\u0026#34;, \u0026#34;20\u0026#34;, mobile=\u0026#34;01012341234\u0026#34;, address=\u0026#34;seoul\u0026#34;) 원하는 의도로 수정해보면\ndef func_param_with_kwargs(name, age, address=0, **kwargs): print(\u0026#34;name=\u0026#34;,end=\u0026#34;\u0026#34;), print(name) print(\u0026#34;age=\u0026#34;,end=\u0026#34;\u0026#34;), print(age) print(\u0026#34;kwargs=\u0026#34;,end=\u0026#34;\u0026#34;), print(kwargs) print(\u0026#34;address=\u0026#34;,end=\u0026#34;\u0026#34;), print(address) func_param_with_kwargs(\u0026#34;정우성\u0026#34;, \u0026#34;20\u0026#34;, mobile=\u0026#34;01012341234\u0026#34;, address=\u0026#34;seoul\u0026#34;) name=정우성 age=20 kwargs={'mobile': '01012341234'} address=seoul\n이렇게 정상적으로 호출이 되어 출력되는것을 확인하실수있습니다.\n위치 인수와 키워드 가변 키워드 인수 (**kwargs) 아래의 코드를 실행해봅시다. def mixed_params(name=\u0026quot;아이유\u0026quot;, *args, age, **kwargs, address): ^ SyntaxError: invalid syntax\naddress 부분에서 SyntaxError: invalid syntax 라는 오류가 발생합니다. 문법상 오류가 난겁니다.\n위의 예시들과같이 위치인수를 정확히 이해하셨다면 해결하실수있습니다.\ndef mixed_params(name=\u0026#34;아이유\u0026#34;, *args, age, **kwargs, address): print(\u0026#34;name=\u0026#34;,end=\u0026#34;\u0026#34;), print(name) print(\u0026#34;args=\u0026#34;,end=\u0026#34;\u0026#34;), print(args) print(\u0026#34;age=\u0026#34;,end=\u0026#34;\u0026#34;), print(age) print(\u0026#34;kwargs=\u0026#34;,end=\u0026#34;\u0026#34;), print(kwargs) print(\u0026#34;address=\u0026#34;,end=\u0026#34;\u0026#34;), print(address) mixed_params(20, \u0026#34;정우성\u0026#34;, \u0026#34;01012341234\u0026#34;, \u0026#34;male\u0026#34; ,mobile=\u0026#34;01012341234\u0026#34;, address=\u0026#34;seoul\u0026#34;) 저의 해결방법은 address 를 가변 키워드 인수에 집어넣고 출력하는 부분을 삭제하였습니다. 그리고, age 를 정상적으로 호출받을수있게 인자를 맨 앞으로 당겨놓고 마지막 부분에 *args , **kwargs 를 넣었더니\ndef mixed_params(age , name=\u0026#34;아이유\u0026#34;, *args, **kwargs): print(\u0026#34;name=\u0026#34;,end=\u0026#34;\u0026#34;), print(name) print(\u0026#34;args=\u0026#34;,end=\u0026#34;\u0026#34;), print(args) print(\u0026#34;age=\u0026#34;,end=\u0026#34;\u0026#34;), print(age) print(\u0026#34;kwargs=\u0026#34;,end=\u0026#34;\u0026#34;), print(kwargs) mixed_params(20, \u0026#34;정우성\u0026#34;, \u0026#34;01012341234\u0026#34;, \u0026#34;male\u0026#34; ,mobile=\u0026#34;01012341234\u0026#34;, address=\u0026#34;seoul\u0026#34;) name=정우성 args=('01012341234', 'male') age=20 kwargs={'mobile': '01012341234', 'address': 'seoul'}\n정상적으로 출력이 되었습니다.\n","date":"2022-01-02T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151964846-19a947e0-45be-421d-9515-84a921077aeb.png","permalink":"https://heetaek.com/p/python-function-parameter/","title":"[Python] 함수 인자와 가변인수(*args), 가변 키워드 인수(**kwargs) 에 대해"},{"content":"CSS position 요약 position 속성을 통해 문서 상에 요소를 배치하는 방법 top,right,bottom,left 속성을 통해 요소의 최종 위치를 결정* top : 요소의 position 기준에 맞는 위쪽에서의 거리(위치)를 설정* bottom : 요소의 position 기준에 맞는 아래쪽에서의 거리(위치)를 설정* left : 요소의 position 기준에 맞는 왼쪽에서의 거리(위치)를 설정* right : 요소의 position 기준에 맞는 오른쪽에서의 거리(위치)를 설정\nposition 속성 position: relative position 속성을 relative 로 설정하게 되면, 요소를 원래 위치에서 벗어나게 배치할 수 있습니다. 위치 지정은 top,bottom,left,right 를 이용해 정할 수 있습니다.\n아래의 예시를 보시면 position은 relative 위치는 top: 28px; , left: 48px 로 이동하여 겹쳐있는것을 볼 수 있습니다.\n#relative { position: relative; top: 28px; left: 48px; } See the Pen Untitled by Bridge (@sosolyht) on CodePen. \u0026nbsp; \u0026nbsp; position: absolute position은 어렵게 생각할것없이 원래의 위치와 상관없이 위치를 지정할 수 있습니다. absolute 는 절대적이다라는 뜻때문에 마음껏 바꿀수있다고 오해하시는 경우가 있습니다. 하지만 absolute 는 부모 요소의 기준으로 위치가 결정 됩니다.\n아래의 예제를 보시면 top: 80px; , right: 16px; 의 값을 주게 되면 relative 기준으로 떨어져있는 것을 보실 수 있습니다.\nbody { position: relative; } .sample { width: 200px; height: 100px; } #absloute { position: absolute; top: 80px; right: 16px; } See the Pen absloute by Bridge (@sosolyht) on CodePen. \u0026nbsp; 참고로 `absolute` 의 요소는 HTML 문서상에서 독립되어 앞뒤에 나온 요소와 상호작용을 하지않습니다 \u0026nbsp; \u0026nbsp; position: fixed fixed 는 화면을 위아래로 스크롤하더라도 브라우저 화면의 특정 부분이 고정되어 움직이지 않습니다. 쉽게 예를들어 웹사이트들어가면 귀찮게 따라다니는 사이드 광고를 생각하시면 될것 같습니다.\n아래의 예시를 참고하시면 될것같습니다.\n#fixed { position: fixed; bottom: 8px; right: 16px; } See the Pen fixed by Bridge (@sosolyht) on CodePen. display 속성 inline inline 특징으로는 \u0026lt;span\u0026gt;,\u0026lt;a\u0026gt;,\u0026lt;em\u0026gt; 태그를 예로 들 수 있습니다.\n\u0026lt;a\u0026gt;A\u0026lt;/a\u0026gt; \u0026lt;span\u0026gt;SPAN\u0026lt;/span\u0026gt; \u0026lt;em\u0026gt;EM\u0026lt;em\u0026gt; 을 작성해보시면 띄어쓰기가 되지않고 한 줄로 보이게됩니다. 그리고 width 와 height 속성을 지정해도 무시되는걸 참고하시길 바랍니다. inline-block inline-block 은 말 그대로 inline 의 특징과 block 의 특징을 모두 가진 요소를 뜻합니다.\n줄바꿈이 이루어지지않습니다. width 와 height 를 지정 할 수 있습니다. 만약 width 와 height 지정하지 않을 경우, inline 과 같이 컨텐츠만큼 영역이 잡힌다. block block 특징으로는 \u0026lt;div\u0026gt;,\u0026lt;p\u0026gt;,\u0026lt;h1\u0026gt; 태그를 예로 들 수 있습니다.\n\u0026lt;div\u0026gt;DIV\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;P\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;H1\u0026lt;/h1\u0026gt; 을 작성해보시면 태그마다 줄바꿈되어 보여지실겁니다. block 은 inline 과는 달리 width,height 등 속성이 모두 반영이 됩니다.\n","date":"2021-12-29T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749810-2ae81f03-b6f1-4c2f-b393-98079352d76d.png","permalink":"https://heetaek.com/p/css-position-%EC%86%8D%EC%84%B1%EA%B3%BC-display-%EC%86%8D%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%B4/","title":"[CSS] position 속성과 display 속성에 대해"},{"content":"python 기초 문법 print print 는 무언가를 출력할때 사용됩니다. 예를 들어,\nprint(\u0026#34;코알못 블로그\u0026#34;) 라고 쓰면 코알못 블로그 라고 출력이 됩니다.\n이와 같이 뭔가를 출력할때 사용되고, 결과값을 확인하기 위한 용도로도 사용됩니다. 변수 (variable) 변수(variable)란 데이터를 저장하기 위해 할당받은 하나의 공간이라 생각하시면됩니다.\n변수는 자신이 원하는 역할을 부여할수있습니다\nname = \u0026#34;앙모띠\u0026#34; age = \u0026#34;32\u0026#34; my_car = \u0026#34;Tico\u0026#34; live = \u0026#34;Seoul\u0026#34; name 은 이름인 \u0026lsquo;앙모띠\u0026rsquo;, age는 나이인 \u0026lsquo;32\u0026rsquo;, my_car 는 자동차인 \u0026lsquo;Tico\u0026rsquo;, live는 사는 곳인 \u0026lsquo;Seoul\u0026rsquo; 이런식으로 원하는 변수명으로 지정할수있습니다.\n다만, 변수명을 지정할때는 조심하셔야할게있습니다. 올바른 변수 이름 : name, _name, my_name, myName 잘못된 변수 이름: 7name, my name 참고하시면 됩니다. 데이터 타입 string (문자열) 큰따움표(\u0026quot;\u0026quot;) 혹은 작은따움표(\u0026rsquo;\u0026rsquo;) 안에 있는 글자들은 string 입니다. 예) \u0026ldquo;안녕하세요\u0026rdquo; , \u0026ldquo;1995\u0026rdquo; , \u0026lsquo;반갑습니다\u0026rsquo; , \u0026lsquo;1128\u0026rsquo;\ninteger (정수) 정수형(Integer)이란 말 그대로 정수를 뜻하는 자료형을 말합니다.\na = 1 a = -100 a = 0 float (실수) 실수형(Floating-point)은 소수점이 포함된 숫자를 말합니다.\na = 0.1 a = -3.56 boolean boolean은 참(True)과 거짓(False)을 나타내는 자료형입니다.\na = True b = False 1 == 1 True 1 == 2 False 2 \u0026gt; 1 True 2 \u0026lt; 1 False 위의 예시와 같이 참(True)과 거짓(False) 를 판별합니다.\n","date":"2021-12-29T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151964846-19a947e0-45be-421d-9515-84a921077aeb.png","permalink":"https://heetaek.com/p/python-syntax/","title":"[Python] 기초 문법"},{"content":"Semantic Web 이란? Semantic Web은 HTML4 에서 HTML5 올라가면서 생기게 되었습니다.\n의미를 정확히 부여하는 기술입니다.\n기존에는 컴퓨터가 메타데이터를 해석하기만 했다면\nSemantic Web은 사람의 눈으로 보기에 용이한 메타데이터와 자연어로 구성되어있습니다.\n예를 들면,\n\u0026lt;div id=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 이렇게 이 div 는 header 라고 나타내었던것을\n\u0026lt;header\u0026gt;\u0026lt;/header\u0026gt; 태그에 header 라고 의미를 부여해 더 효율적으로 작성할수있습니다.\nSemantic Tag 란? Semantic Tag 도 Semantic Web 과 마찬가지로 \u0026lsquo;의미가 있는\u0026rsquo; 태그를 뜻합니다.\n이걸 언제써야하는지는\nimg 태그와 css의 background-image 를 예시로 들면\n\u0026lt;img id=\u0026#34;my-img\u0026#34; alt=\u0026#34;내 얼굴\u0026#34; src=\u0026#34;/img/profile.png\u0026#34;\u0026gt; 만약 /img/profile.png 의 사진의 경로가 잘못되어 브라우저가 불러오지 못하는 상황이 있을때 alt 태그로 이 사진은 얼굴 사진이라는것을 알 수 있습니다.\n허나 css 에 background-image 를 사용하게되면\n\u0026lt;div id=\u0026#34;my-img\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; #my-img { background-image: /img/profile.png } 단지 div 에 이미지를 추가 한 것일뿐 어떠한 정보나 메타데이터가 없습니다.\n웹의 SEO 측면에서 봤을때도 메타데이터가 없는 후자의 CSS 방식은 불리할수밖에없습니다.\n참고로 img 와 같은 Semantic Tag를 조금 소개해드리자면\n\u0026lt;header\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;section\u0026gt; \u0026lt;article\u0026gt; 등이 있습니다.\n더 많은 정보는 W3C 를 참고 바랍니다.\n","date":"2021-12-27T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151965048-eba453c3-ecf3-43b5-a8e6-1a260ce5ba61.png","permalink":"https://heetaek.com/p/semantic-web/","title":"[HTML] Semantic Web, Semantic Tag 이 뭔가요?"},{"content":"파이썬 회문판별 word = \u0026#39;123454321\u0026#39; print(word == word[::-1]) 파이썬 array 를 이용해\nex)\narr = [0,1,2,3,4,5,6,7,8,9] arr[::2] # 처음부터 끝까지 두 칸 간격으로 [0,2,4,6,8] arr[1::2] # index 1 부터 끝까지 두 칸 간격으로 [1,3,5,7,9] arr[::-1] # 처음부터 끝까지 -1칸 간격으로 ( == 역순으로) [9,8,7,6,5,4,3,2,1,0] arr[::-2] # 처음부터 끝까지 -2칸 간격으로 ( == 역순, 두 칸 간격으로) [9,7,5,3,1] arr[3::-1] # index 3 부터 끝까지 -1칸 간격으로 ( == 역순으로) [3,2,1,0] arr[1:6:2] # index 1 부터 index 6 까지 두 칸 간격으로 [1,3,5] word 와 word[::-1] 정방향과 역방향으로 검사 후\n회문이면 True 아니면 False\n","date":"2021-12-25T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/151965127-16588fd3-4c13-422d-aedf-3b9a8b0d37dd.png","permalink":"https://heetaek.com/p/palindrome/","title":"[알고리즘] 회문 판별 시퀀스 뒤집기(Palindrome)"},{"content":"\nNode.js 란? 먼저 Node.js 를 알고싶으면 JavaScript 에 대해 알아야한다.\n(그래서 현재 JavaScript 에 대해 공부중이다. 2022.05.21)\nNode.js는 Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript 런타임(환경)이다.\nV8이 어떠한건지 대충 둘러보셔도 좋습니다. Node.js 를 통해 다양한 자바스크립트 애플리케이션을 실행할 수 있지만 보통 서버 사이드에서 많이 사용된다. 그렇다고 서버사이드 스크립트 언어가 아닌 자바스크립트로 동작하는 프로그램이다.\nNon-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 처리 성능을 가지고 있는 것이 특징이다.\n내장 HTTP 서버 라이브러리를 포함하고 있어 웹 서버에서 아파치 등의 별도 소프트웨어 없이 동작하는 것이 가능하며, 이를 통한 웹 서버의 동작에 있어 더 많은 통제에서 벗어나 여러 가지 기능을 가능하게 한다.\n즉, Node.js를 통해 웹어플리케이션이 더욱 발전하게 되었으며, 정적인 홈페이지 뿐만 아니라 쇼핑몰, 티켓 예매사이트, 블로그 등 데이터가 변해가는 사이트를 만들 수 있으며, 여러 개발자가 만든 프로그램과 게임을 웹상에서 구동시켜 안드로이드폰, 아이폰, 윈도우PC, 맥 등 플랫폼의 제약에서 벗어나 어디든 상관없이 실행 가능하게 해준다.\n물론 단순히 웹에서 실행 가능한 게임을 만들려면 JavaScript 만으로도 가능하지만 좀 더 진화 된 프로그램으로 실시간 온라인 채팅, 실시간 온라인 게임 등 실시간 기능을 넣거나, 로그인 기능을 넣어 유저를 관리하고 점수를 관리하는 데이터베이스 기능을 Node.js를 통해 만들 수가 있다.\nNode.js 특징 위에 보면, Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 처리 성능을 가지고 있는 것이 특징이라 했는데 정확히 어떤 것인지 알아보자.\n예를 들어, 휴게소의 푸트코트를 상상해보면 키오스크에서 모두 주문을 받고 음식은 각 입점된 식당에서 조리를 한다.\n음식이 완성된 순서대로 호출을 하고 손님은 음식을 픽업한다.\n여기서 계산을 담당하는 키오스크가 단일스레드 이고, 각 요리를 완성해서 호출하는 식당들은 비동기 방식 이다.\n입력은 하나의 스레드에서 받지만 순서대로 처리하지 않고 먼저 처리된 결과 값을 이벤트로 반환해주는 방식이 Node.js 가 사용하는 단일스레드 비동기 방식이다.\nReference\nhttp://sblog.netraweb.com/node-js-%EA%B0%95%EC%A2%8C-node-js-%EB%9E%80-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%86%8C%EA%B0%9C/ https://medium.com/sjk5766/javascript-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%B5%EC%8B%AC-event-loop-%EC%A0%95%EB%A6%AC-422eb29231a8 https://jongminfire.dev/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%86%B5%EC%8B%A0 ","date":"2021-01-01T00:00:00Z","image":"https://user-images.githubusercontent.com/2377807/181749612-780dfc50-1e97-4e26-b1ef-f27591c55ec1.png","permalink":"https://heetaek.com/p/about-nodejs/","title":"[Node.js] 개념 이해하기"},{"content":"사전 셋팅 Python 3.8.10 설치 https://www.python.org/ftp/python/3.8.10/python-3.8.10-macos11.pkg\nNode.js 설치 brew install node\nAWS 설정 IAM 계정의 Access Key 와 Secret Key 를 가지고 설정합니다.\n지역은 사용하시는 리전\nAWS Access Key ID [None]: AKI******** AWS Secret Access Key [None]: lSrC************* Default region name [None]: ap-northeast-2 Default output format [None]: json 기타 설정 ConsoleMe 의 Makefile 에는 pip 명령어만 인식하기때문에,\n맥에서 기본으로 지정되는 pip3 -\u0026gt; pip 로 변경해야됩니다.\nvim ~/.bashrc\nalias pip=\u0026ldquo;pip3\u0026rdquo;\n입력하고\n저장 후 종료\nsource ~/.bashrc 로 초기화\npython -m pip install --upgrade pip\n로 pip 업그레이드\n파이썬 가상환경 설정 venv 라는 가상화 패키지로 env 라는 이름의 가상환경 설정\npython -m venv env\n가상환경 활성화 . env/bin/activate\nConsoleMe 설치 make install\n","date":"0001-01-01T00:00:00Z","permalink":"https://heetaek.com/p/","title":""}]