<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[자료구조] 스택(Stack) 과 큐(Queue) | 희택의 노력</title><meta name=keywords content="스택,큐,스택과 큐"><meta name=description content="스택 (Stack) 스택(Stack)은 &lsquo;쌓다&rsquo; 라는 의미로, 데이터를 쌓아 올린 형태의 자료구조이다. 접근 방법은 LIFO(Last In First Out) 라고 부르며, 마지"><meta name=author content="최희택"><link rel=canonical href=https://heetaek.com/post/stack-queue/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://heetaek.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heetaek.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heetaek.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heetaek.com/apple-touch-icon.png><link rel=mask-icon href=https://heetaek.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-QPR5XGZ8DK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QPR5XGZ8DK",{anonymize_ip:!1})}</script><meta property="og:title" content="[자료구조] 스택(Stack) 과 큐(Queue)"><meta property="og:description" content="스택 (Stack) 스택(Stack)은 &lsquo;쌓다&rsquo; 라는 의미로, 데이터를 쌓아 올린 형태의 자료구조이다. 접근 방법은 LIFO(Last In First Out) 라고 부르며, 마지"><meta property="og:type" content="article"><meta property="og:url" content="https://heetaek.com/post/stack-queue/"><meta property="og:image" content="https://heetaek.com/profile.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-13T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-13T00:00:00+00:00"><meta property="og:site_name" content="희택의 노력"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://heetaek.com/profile.png"><meta name=twitter:title content="[자료구조] 스택(Stack) 과 큐(Queue)"><meta name=twitter:description content="스택 (Stack) 스택(Stack)은 &lsquo;쌓다&rsquo; 라는 의미로, 데이터를 쌓아 올린 형태의 자료구조이다. 접근 방법은 LIFO(Last In First Out) 라고 부르며, 마지"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://heetaek.com/post/"},{"@type":"ListItem","position":3,"name":"[자료구조] 스택(Stack) 과 큐(Queue)","item":"https://heetaek.com/post/stack-queue/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[자료구조] 스택(Stack) 과 큐(Queue)","name":"[자료구조] 스택(Stack) 과 큐(Queue)","description":"스택 (Stack) 스택(Stack)은 \u0026lsquo;쌓다\u0026rsquo; 라는 의미로, 데이터를 쌓아 올린 형태의 자료구조이다. 접근 방법은 LIFO(Last In First Out) 라고 부르며, 마지","keywords":["스택","큐","스택과 큐"],"articleBody":"스택 (Stack) 스택(Stack)은 ‘쌓다’ 라는 의미로, 데이터를 쌓아 올린 형태의 자료구조이다.\n접근 방법은 LIFO(Last In First Out) 라고 부르며, 마지막에 넣은 요소가 먼저 나온다는 의미다.\n아래가 막혀있고 위가 뚫린 형태로 차곡차곡 쌓인다.\n이러한 구조이기때문에 마지막에 삽입한 요소는 처음으로 삭제할 수 있다.\n스택에서 삽입은 PUSH, 삭제는 POP 이라는 용어로 사용하고 있다.\n실사용 예제  브라우저에서 뒤로 가기 문서작업에서 Ctrl + Z 실행취소 (undo) 후위 표기법 (컴퓨터가 어떤식으로 사칙 연산을 하는지 이해하는 용도)  큐(Queue) 큐는 단순히 스택의 반대 개념이다.\n접근 방법은 FIFO (First In First Out)라고 부르며, 먼저 들어간 데이터가 먼저 나오는 구조다.\n은행업무를 보기 위해 줄을 선 모습을 상상해 볼 수 있다.\n번호표를 먼저 뽑은 사람이 먼저 업무를 처리하고 나가고, 말 그대로 ‘FIFO’ 다.\n또 다른 예시로 CPU 는 하나의 task 가 처리가 완료되어야 다음 task 로 넘어가 처리하는것처럼 실행 순서대로 처리한다.\n실사용 예제  은행 업무 프린터에서 여러 문서를 순서대로 인쇄   Reference\n  https://www.fun-coding.org/Chapter06-stack-live.html https://www.fun-coding.org/Chapter05-queue-live.html https://hanamon.kr/%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0-queue-%ed%81%90-feat-buffering/  ","wordCount":"413","inLanguage":"ko","datePublished":"2022-05-13T00:00:00Z","dateModified":"2022-05-13T00:00:00Z","author":{"@type":"Person","name":"최희택"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://heetaek.com/post/stack-queue/"},"publisher":{"@type":"Organization","name":"희택의 노력","logo":{"@type":"ImageObject","url":"https://heetaek.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://heetaek.com accesskey=h title="heetaek.com (Alt + H)">heetaek.com</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://heetaek.com/categories/ title=카테고리><span>카테고리</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://heetaek.com>Home</a>&nbsp;»&nbsp;<a href=https://heetaek.com/post/>Posts</a></div><h1 class=post-title>[자료구조] 스택(Stack) 과 큐(Queue)</h1><div class=post-meta><span title="2022-05-13 00:00:00 +0000 UTC">2022-05-13</span>&nbsp;·&nbsp;1 분&nbsp;·&nbsp;최희택</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ec%8a%a4%ed%83%9d-stack aria-label="스택 (Stack)">스택 (Stack)</a><ul><ul><li><a href=#%ec%8b%a4%ec%82%ac%ec%9a%a9-%ec%98%88%ec%a0%9c aria-label="실사용 예제">실사용 예제</a></li></ul></ul></li><li><a href=#%ed%81%90queue aria-label=큐(Queue)>큐(Queue)</a><ul><ul><li><a href=#%ec%8b%a4%ec%82%ac%ec%9a%a9-%ec%98%88%ec%a0%9c-1 aria-label="실사용 예제">실사용 예제</a></li></ul></ul></li></ul></div></details></div><div class=post-content><h1 id=스택-stack>스택 (Stack)<a hidden class=anchor aria-hidden=true href=#스택-stack>#</a></h1><p>스택(Stack)은 &lsquo;쌓다&rsquo; 라는 의미로, 데이터를 쌓아 올린 형태의 자료구조이다.</p><p>접근 방법은 LIFO(Last In First Out) 라고 부르며, 마지막에 넣은 요소가 먼저 나온다는 의미다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/2377807/168406214-2bc7bf49-33b0-41fe-b294-7671812fac71.png alt=image></p><p>아래가 막혀있고 위가 뚫린 형태로 차곡차곡 쌓인다.</p><p>이러한 구조이기때문에 마지막에 삽입한 요소는 처음으로 삭제할 수 있다.</p><p>스택에서 삽입은 <code>PUSH</code>, 삭제는 <code>POP</code> 이라는 용어로 사용하고 있다.</p><h3 id=실사용-예제>실사용 예제<a hidden class=anchor aria-hidden=true href=#실사용-예제>#</a></h3><ul><li>브라우저에서 뒤로 가기</li><li>문서작업에서 Ctrl + Z</li><li>실행취소 (undo)</li><li>후위 표기법 (컴퓨터가 어떤식으로 사칙 연산을 하는지 이해하는 용도)</li></ul><h1 id=큐queue>큐(Queue)<a hidden class=anchor aria-hidden=true href=#큐queue>#</a></h1><p>큐는 단순히 스택의 반대 개념이다.</p><p>접근 방법은 FIFO (First In First Out)라고 부르며, 먼저 들어간 데이터가 먼저 나오는 구조다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/2377807/168406982-c526f22d-e271-4e42-a5e2-1df59e1a27b6.png alt=image></p><p>은행업무를 보기 위해 줄을 선 모습을 상상해 볼 수 있다.</p><p>번호표를 먼저 뽑은 사람이 먼저 업무를 처리하고 나가고, 말 그대로 &lsquo;FIFO&rsquo; 다.</p><p>또 다른 예시로 CPU 는 하나의 task 가 처리가 완료되어야 다음 task 로 넘어가 처리하는것처럼 실행 순서대로 처리한다.</p><h3 id=실사용-예제-1>실사용 예제<a hidden class=anchor aria-hidden=true href=#실사용-예제-1>#</a></h3><ul><li>은행 업무</li><li>프린터에서 여러 문서를 순서대로 인쇄</li></ul><blockquote><p>Reference</p></blockquote><ul><li><a href=https://www.fun-coding.org/Chapter06-stack-live.html>https://www.fun-coding.org/Chapter06-stack-live.html</a></li><li><a href=https://www.fun-coding.org/Chapter05-queue-live.html>https://www.fun-coding.org/Chapter05-queue-live.html</a></li><li><a href=https://hanamon.kr/%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0-queue-%ed%81%90-feat-buffering/>https://hanamon.kr/%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0-queue-%ed%81%90-feat-buffering/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://heetaek.com/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/>자료구조</a></li><li><a href=https://heetaek.com/tags/stack/>Stack</a></li><li><a href=https://heetaek.com/tags/queue/>Queue</a></li></ul><nav class=paginav><a class=prev href=https://heetaek.com/post/network-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%98-%EA%B7%9C%EC%B9%99/><span class=title>« 이전 페이지</span><br><span>[Network] 네트워크의 기본 규칙 (프로토콜, OSI 모델과 TCP/IP 모델)</span></a>
<a class=next href=https://heetaek.com/post/array-list/><span class=title>다음 페이지 »</span><br><span>[자료구조] 배열(Array) 과 리스트(List)</span></a></nav></footer><script src=https://utteranc.es/client.js repo=sosolyht/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://heetaek.com>heetaek.com</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="복사";function s(){e.innerText="복사완료!",setTimeout(()=>{e.innerText="복사"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>