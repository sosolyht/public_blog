<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Agile] TDD 는 왜 필요한가? | 희택의 노력</title><meta name=keywords content="tdd,Test Driven Development"><meta name=description content="테스트가 개발을 주도한다"><meta name=author content="최희택"><link rel=canonical href=https://heetaek.com/post/tdd/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://heetaek.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heetaek.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heetaek.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heetaek.com/apple-touch-icon.png><link rel=mask-icon href=https://heetaek.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-QPR5XGZ8DK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QPR5XGZ8DK",{anonymize_ip:!1})}</script><meta property="og:title" content="[Agile] TDD 는 왜 필요한가?"><meta property="og:description" content="테스트가 개발을 주도한다"><meta property="og:type" content="article"><meta property="og:url" content="https://heetaek.com/post/tdd/"><meta property="og:image" content="https://heetaek.com/profile.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-10T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-10T00:00:00+00:00"><meta property="og:site_name" content="희택의 노력"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://heetaek.com/profile.png"><meta name=twitter:title content="[Agile] TDD 는 왜 필요한가?"><meta name=twitter:description content="테스트가 개발을 주도한다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://heetaek.com/post/"},{"@type":"ListItem","position":3,"name":"[Agile] TDD 는 왜 필요한가?","item":"https://heetaek.com/post/tdd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Agile] TDD 는 왜 필요한가?","name":"[Agile] TDD 는 왜 필요한가?","description":"테스트가 개발을 주도한다","keywords":["tdd","Test Driven Development"],"articleBody":"1. TDD(테스트 주도 개발) 이란? 실패하는 테스트를 만들고, 그 테스트가 통과하는 제품을 만들면 결국은 원하는 기능이 동작하게 된다는 개발방법론이다.\n쉽게 설명하면 지금 당장은 귀찮지만 나중에는 유지보수면에서도 쉬워지고 프로그래밍 시간이 단축된다.\n특히, Python 같은 동적타입언어는 TDD 가 필수다.\n2. Unit Test (단위 테스트)  기능 테스트를 작성해서 사용자 관점의 새로운 기능성을 정의하는 것부터 시작한다. 기능 테스트가 실패하고 나면 어떻게 코드를 작성해야 테스트를 통과할지를 생각해보도록 한다. 이 시점에서 하나 또는 그 이상의 단위 테스트를 이용해서 어떻게 코드가 동작해야 하는지 정의한다. 단위 테스트가 실패하고 나면 단위 테스트를 통과할 수 있을 정도의 최소한의 코드만 작성한다. 기능 테스트가 완전해질 때까지 과정 2와 3을 반복해야 할 수도 있다. 기능 테스트를 재실행해서 통과하는지 또는 제대로 동작하는지 확인한다. 이 과정에서 새로운 단위 테스트를 작성해야 할 수도 있다.  단위 테스트(unit Test)란? 말 그대로 한 단위(일반적으로 class)만을 테스트하는 것이다.\nTDD-개발주기\nTDD 개발주기 위 그림은 TDD의 개발주기를 표현한 것이다.\n{ Red } 단계에서는 실패하는 테스트 코드를 먼저 작성한다. { Green } 단계에서는 테스트 코드를 성공시키기 위한 실제 코드를 작성한다. { Blue } 단계에서는 중복 코드 제거, 일반화 등의 리팩토링을 수행한다. 중요한 것은 실패하는 테스트 코드를 작성할 때까지 실제 코드를 작성하지 않는 것과, 실패하는 테스트를 통과할 정도의 최소 실제 코드를 작성해야하는 것이다. 이를 통해 실제 코드에 대해 기대되는 바를 보다 명확하게 정의 함으로써 불필요한 설계를 피할 수 있고, 정확한 요구 사항에 집중할 수 있다.\n일반 개발 방식과 TDD 개발 방식의 비교 일반 개발 방식 보통 개발 방식은 ‘요구사항 분석 → 설계 → 개발 → 테스트 → 배포’의 형태의 개발 주기를 갖는다.\n기존프로세스\n이러한 방식은 소프트웨어 개발을 느리게 하는 잠재적 위험이 존재한다.\n그 이유는 아래와 같다.\n소비자의 요구사항이 처음부터 명확하지 않을 수 있다. 따라서 처음부터 완벽한 설계는 어렵다. 자체 버그 검출 능력 저하 또는 소스코드의 품질이 저하될 수 있다. 자체 테스트 비용이 증가할 수 있다. 이러한 문제점이 발생되는 이유는 어느 프로젝트든 초기 설계가 완벽하다고 말할 수 없기 때문이다.\n고객의 요구사항 또는 디자인의 오류 등 많은 외부 또는 내부 조건에 의해 재설계하여 점진적으로 완벽한 설계로 나아간다.\n재설계로 인해 개발자는 코드를 삽입, 수정, 삭제하는 과정에서 불필요한 코드가 남거나 중복처 될 가능성이 크다.\n결론적으로 이러한 코드들은 재사용이 어렵고 관리가 어려워서 유지보수를 어렵게 만든다.\n작은 부분의 기능 수정에도 모든 부분을 테스트해야 하므로 전체적인 버그를 검출하기 어려워진다. 따라서 자체 버그 검출 능력이 저하된다. 그 결과 어디서 버그가 발생할지 모르기 때문에 잘못된 코드도 고치지 않으려 하는 현상이 나타나게 된다.\n이 현상은 소스코드의 품질 저하와 직결된다. 작은 수정에도 모든 기능을 다시 테스트해야하는 문제가 발생하여 자체 테스트 비용이 증가된다.\nTDD 개발 방식 TDD와 일반적인 개발 방식의 가장 큰 차이점은 테스트 코드를 작성한 뒤에 실제 코드를 작성한다는 것이다.\n디자인(설계) 단계에서 프로그래밍 목적을 반드시 미리 정의해야만 하고, 무엇보다 테스트해야 할지 미리 정의(테스트 케이스 작성)해야만 한다.\n테스트 코드를 작성하는 도중 발생하는 예외 사항(버그 및 수정사항)은 테스트 케이스에 추가하고 설계를 개선한다.\n이후 테스트가 통과된 코드만을 코드 개발 단계에서 실제 코드로 작성한다.\nTDD프로세스\n이러한 반복적인 단계가 진행되면서 자연스럽게 코드의 버그가 줄어들고 소스코드는 간결해진다.\n또한 테스트 케이스 작성으로 인해 자연스럽게 설계가 개선됨으로 재설계 시간이 절감된다.\nTDD의 대표적인 Tool ‘JUnit’ JUnit란? JUnit는 현재 전 세계적으로 가장 널리 사용되는 ‘Java 단위 테스트 프레임워크’이다.\n에릭 감마와 켄트 벡이 탄생시켰다. JUnit을 시작으로 CUnit(C언어), CPPUnit(C++), PyUnit(Python) 등 xUnit 프레임워크가 탄생하게 되었다.\nxUnit란? 자바의 단위 테스팅 프레임워크인 JUnit만 있는 것이 아니다.\n다른 언어도 단위 테스트를 위한 프레임워크가 존재하며 보통 이름을 xUnit이라 지칭한다. xUnit의 종류는 아래 표와 같다.\nxUnit 종류\nTDD 개발 방식의 장점 보다 튼튼한 객체 지향적인 코드 생산 TDD는 코드의 재사용 보장을 명시하므로 TDD를 통한 소프트웨어 개발 시 기능 별 철저한 모듈화가 이뤄진다.\n이는 종속성과 의존성이 낮은 모듈로 조합된 소프트웨어 개발을 가능하게 하며 필요에 따라 모듈을 추가하거나 제거해도 소프트웨어 전체 구조에 영향을 미치치 않게 된다.\n재설계 시간의 단축 테스트 코드를 먼저 작성하기 때문에 개발자가 지금 무엇을 해야하는지 분명히 정의하고 개발을 시작하게된다. 또한 테스트 시나리오를 작성하면서 다양한 예외사항에 대해 생각해 볼 수 있다. 이는 개발 진행 중 소프트웨어의 전반적인 설계가 변경되는 일을 방지할 수 있다.\n디버깅 시간의 단축 이는 유닛 테스팅을 하는 이점이기도하다. 예를 들면 사용자의 데이터가 잘못 나온다면 DB의 문제인지, 비즈니스 레이어의 문제인지 UI의 문제인지 실제 모든 레이어들을 전부 디버깅 해야하지만, TDD의 경우 자동화 된 유닛 테스팅을 전제하므로 특정 버그를 손 쉰게 찾아낼 수 있다.\n테스트 문서의 대체 가능 주로 SI 프로젝트 진행 과정에서 어떤 요소들이 테스트 되었는지 테스트 정의서를 만든다. 이것은 단순 통합 테스트문서에 지나지 않는다. 하지만 TDD를 하게 될 경우 테스팅을 자동화 시킴과 동시에 보다 정확한 테스트 근거를 산출 할 수 있다.\n추가 구현의 용의함 개발이 완료된 소프트웨어에 어떤 기능을 추가할 때 가장 우려되는 점은 해당 기능이 기존 코드에 어떤 영향을 미칠지 알지 못한다는 것이다. 하지만 TDD의 경우 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있다.\n이러한 TDD의 장점에도 불구하고 모두가 이 개발 프로세스를 따르는 것은 아니다. 그 이유는 무엇일까?\nTDD 개발 방식의 단점 가장 큰 단점은 바로 생산성 저하이다. 개발 속도가 느려진다고 생각하는 사람이 많기 때문에 TDD에 대해 반신반의 한다.\n왜냐하면 처음부터 2개의 코드를 짜야하고 중간중간 테스트를 하면서 고쳐나가야하기 때문이다.\nTDD 방식의 개발 시간은 일반적인 개발 방식에 비해 대략 10~30% 정도로 늘어난다.\nSI 프로젝트에서는 소프트웨어의 품질보다는 납기일 준수가 훨씬 중요하기 때문에 TDD 방식을 잘 사용하지 않는다.\nTDD를 하기 어려운 이유? 이제까지 자신이 개발하던 방식을 많이 바꿔야 한다. 몸에 체득한 것이 많을 수록 바꾸기 어렵다.\n오히려 개발을 별로 해보지 않은 사람들에겐 적용하기가 쉽다.\nTDD는 이렇게 해야된다는 이미지(틀)이 있다. 반드시 툴(단위 테스트 프레임워크)을 써서 개발해야 된다. 라고 생각한다. 이러한 규칙에 얽매이는 것은 애자일 방식이 아니다. 결국엔 규칙에 얽매여 똑같은 테스트를 copy\u0026paste 한다. 도구/규칙에 집착하다 보니 TDD가 어려워지는 것이다.\n","wordCount":"2729","inLanguage":"ko","datePublished":"2022-05-10T00:00:00Z","dateModified":"2022-05-10T00:00:00Z","author":{"@type":"Person","name":"최희택"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://heetaek.com/post/tdd/"},"publisher":{"@type":"Organization","name":"희택의 노력","logo":{"@type":"ImageObject","url":"https://heetaek.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://heetaek.com accesskey=h title="heetaek.com (Alt + H)">heetaek.com</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://heetaek.com/categories/ title=카테고리><span>카테고리</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://heetaek.com>Home</a>&nbsp;»&nbsp;<a href=https://heetaek.com/post/>Posts</a></div><h1 class=post-title>[Agile] TDD 는 왜 필요한가?</h1><div class=post-description>테스트가 개발을 주도한다</div><div class=post-meta><span title="2022-05-10 00:00:00 +0000 UTC">2022-05-10</span>&nbsp;·&nbsp;6 분&nbsp;·&nbsp;최희택</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-tdd%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%a3%bc%eb%8f%84-%ea%b0%9c%eb%b0%9c-%ec%9d%b4%eb%9e%80 aria-label="1. TDD(테스트 주도 개발) 이란?">1. TDD(테스트 주도 개발) 이란?</a></li><li><a href=#2-unit-test-%eb%8b%a8%ec%9c%84-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="2. Unit Test (단위 테스트)">2. Unit Test (단위 테스트)</a></li></ul></div></details></div><div class=post-content><h1 id=1-tdd테스트-주도-개발-이란>1. TDD(테스트 주도 개발) 이란?<a hidden class=anchor aria-hidden=true href=#1-tdd테스트-주도-개발-이란>#</a></h1><p>실패하는 테스트를 만들고, 그 테스트가 통과하는 제품을 만들면 결국은 원하는 기능이 동작하게 된다는 개발방법론이다.<br>쉽게 설명하면 지금 당장은 귀찮지만 나중에는 유지보수면에서도 쉬워지고 프로그래밍 시간이 단축된다.<br>특히, Python 같은 동적타입언어는 TDD 가 필수다.</p><h1 id=2-unit-test-단위-테스트>2. Unit Test (단위 테스트)<a hidden class=anchor aria-hidden=true href=#2-unit-test-단위-테스트>#</a></h1><ol><li>기능 테스트를 작성해서 사용자 관점의 새로운 기능성을 정의하는 것부터 시작한다.</li><li>기능 테스트가 실패하고 나면 어떻게 코드를 작성해야 테스트를 통과할지를 생각해보도록 한다. 이 시점에서 하나 또는 그 이상의 단위 테스트를 이용해서 어떻게 코드가 동작해야 하는지 정의한다.</li><li>단위 테스트가 실패하고 나면 단위 테스트를 통과할 수 있을 정도의 최소한의 코드만 작성한다. 기능 테스트가 완전해질 때까지 과정 2와 3을 반복해야 할 수도 있다.</li><li>기능 테스트를 재실행해서 통과하는지 또는 제대로 동작하는지 확인한다. 이 과정에서 새로운 단위 테스트를 작성해야 할 수도 있다.</li></ol><p>단위 테스트(unit Test)란?
말 그대로 한 단위(일반적으로 class)만을 테스트하는 것이다.</p><p>TDD-개발주기</p><p>TDD 개발주기
위 그림은 TDD의 개발주기를 표현한 것이다.</p><p>{ Red } 단계에서는 실패하는 테스트 코드를 먼저 작성한다.
{ Green } 단계에서는 테스트 코드를 성공시키기 위한 실제 코드를 작성한다.
{ Blue } 단계에서는 중복 코드 제거, 일반화 등의 리팩토링을 수행한다.
중요한 것은 실패하는 테스트 코드를 작성할 때까지 실제 코드를 작성하지 않는 것과, 실패하는 테스트를 통과할 정도의 최소 실제 코드를 작성해야하는 것이다. 이를 통해 실제 코드에 대해 기대되는 바를 보다 명확하게 정의 함으로써 불필요한 설계를 피할 수 있고, 정확한 요구 사항에 집중할 수 있다.</p><p>일반 개발 방식과 TDD 개발 방식의 비교
일반 개발 방식
보통 개발 방식은 ‘요구사항 분석 → 설계 → 개발 → 테스트 → 배포’의 형태의 개발 주기를 갖는다.</p><p>기존프로세스</p><p>이러한 방식은 소프트웨어 개발을 느리게 하는 잠재적 위험이 존재한다.</p><p>그 이유는 아래와 같다.</p><p>소비자의 요구사항이 처음부터 명확하지 않을 수 있다.
따라서 처음부터 완벽한 설계는 어렵다.
자체 버그 검출 능력 저하 또는 소스코드의 품질이 저하될 수 있다.
자체 테스트 비용이 증가할 수 있다.
이러한 문제점이 발생되는 이유는 어느 프로젝트든 초기 설계가 완벽하다고 말할 수 없기 때문이다.</p><p>고객의 요구사항 또는 디자인의 오류 등 많은 외부 또는 내부 조건에 의해 재설계하여 점진적으로 완벽한 설계로 나아간다.</p><p>재설계로 인해 개발자는 코드를 삽입, 수정, 삭제하는 과정에서 불필요한 코드가 남거나 중복처 될 가능성이 크다.</p><p>결론적으로 이러한 코드들은 재사용이 어렵고 관리가 어려워서 유지보수를 어렵게 만든다.</p><p>작은 부분의 기능 수정에도 모든 부분을 테스트해야 하므로 전체적인 버그를 검출하기 어려워진다. 따라서 자체 버그 검출 능력이 저하된다. 그 결과 어디서 버그가 발생할지 모르기 때문에 잘못된 코드도 고치지 않으려 하는 현상이 나타나게 된다.</p><p>이 현상은 소스코드의 품질 저하와 직결된다. 작은 수정에도 모든 기능을 다시 테스트해야하는 문제가 발생하여 자체 테스트 비용이 증가된다.</p><p>TDD 개발 방식
TDD와 일반적인 개발 방식의 가장 큰 차이점은 테스트 코드를 작성한 뒤에 실제 코드를 작성한다는 것이다.</p><p>디자인(설계) 단계에서 프로그래밍 목적을 반드시 미리 정의해야만 하고, 무엇보다 테스트해야 할지 미리 정의(테스트 케이스 작성)해야만 한다.</p><p>테스트 코드를 작성하는 도중 발생하는 예외 사항(버그 및 수정사항)은 테스트 케이스에 추가하고 설계를 개선한다.</p><p>이후 테스트가 통과된 코드만을 코드 개발 단계에서 실제 코드로 작성한다.</p><p>TDD프로세스</p><p>이러한 반복적인 단계가 진행되면서 자연스럽게 코드의 버그가 줄어들고 소스코드는 간결해진다.</p><p>또한 테스트 케이스 작성으로 인해 자연스럽게 설계가 개선됨으로 재설계 시간이 절감된다.</p><p>TDD의 대표적인 Tool ‘JUnit’
JUnit란?
JUnit는 현재 전 세계적으로 가장 널리 사용되는 ‘Java 단위 테스트 프레임워크’이다.</p><p>에릭 감마와 켄트 벡이 탄생시켰다. JUnit을 시작으로 CUnit(C언어), CPPUnit(C++), PyUnit(Python) 등 xUnit 프레임워크가 탄생하게 되었다.</p><p>xUnit란?
자바의 단위 테스팅 프레임워크인 JUnit만 있는 것이 아니다.</p><p>다른 언어도 단위 테스트를 위한 프레임워크가 존재하며 보통 이름을 xUnit이라 지칭한다. xUnit의 종류는 아래 표와 같다.</p><p>xUnit 종류</p><p>TDD 개발 방식의 장점
보다 튼튼한 객체 지향적인 코드 생산
TDD는 코드의 재사용 보장을 명시하므로 TDD를 통한 소프트웨어 개발 시 기능 별 철저한 모듈화가 이뤄진다.</p><p>이는 종속성과 의존성이 낮은 모듈로 조합된 소프트웨어 개발을 가능하게 하며 필요에 따라 모듈을 추가하거나 제거해도 소프트웨어 전체 구조에 영향을 미치치 않게 된다.</p><p>재설계 시간의 단축
테스트 코드를 먼저 작성하기 때문에 개발자가 지금 무엇을 해야하는지 분명히 정의하고 개발을 시작하게된다. 또한 테스트 시나리오를 작성하면서 다양한 예외사항에 대해 생각해 볼 수 있다. 이는 개발 진행 중 소프트웨어의 전반적인 설계가 변경되는 일을 방지할 수 있다.</p><p>디버깅 시간의 단축
이는 유닛 테스팅을 하는 이점이기도하다. 예를 들면 사용자의 데이터가 잘못 나온다면 DB의 문제인지, 비즈니스 레이어의 문제인지 UI의 문제인지 실제 모든 레이어들을 전부 디버깅 해야하지만, TDD의 경우 자동화 된 유닛 테스팅을 전제하므로 특정 버그를 손 쉰게 찾아낼 수 있다.</p><p>테스트 문서의 대체 가능
주로 SI 프로젝트 진행 과정에서 어떤 요소들이 테스트 되었는지 테스트 정의서를 만든다. 이것은 단순 통합 테스트문서에 지나지 않는다. 하지만 TDD를 하게 될 경우 테스팅을 자동화 시킴과 동시에 보다 정확한 테스트 근거를 산출 할 수 있다.</p><p>추가 구현의 용의함
개발이 완료된 소프트웨어에 어떤 기능을 추가할 때 가장 우려되는 점은 해당 기능이 기존 코드에 어떤 영향을 미칠지 알지 못한다는 것이다. 하지만 TDD의 경우 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있다.</p><p>이러한 TDD의 장점에도 불구하고 모두가 이 개발 프로세스를 따르는 것은 아니다. 그 이유는 무엇일까?</p><p>TDD 개발 방식의 단점
가장 큰 단점은 바로 생산성 저하이다.
개발 속도가 느려진다고 생각하는 사람이 많기 때문에 TDD에 대해 반신반의 한다.</p><p>왜냐하면 처음부터 2개의 코드를 짜야하고 중간중간 테스트를 하면서 고쳐나가야하기 때문이다.</p><p>TDD 방식의 개발 시간은 일반적인 개발 방식에 비해 대략 10~30% 정도로 늘어난다.</p><p>SI 프로젝트에서는 소프트웨어의 품질보다는 납기일 준수가 훨씬 중요하기 때문에 TDD 방식을 잘 사용하지 않는다.</p><p>TDD를 하기 어려운 이유?
이제까지 자신이 개발하던 방식을 많이 바꿔야 한다.
몸에 체득한 것이 많을 수록 바꾸기 어렵다.</p><p>오히려 개발을 별로 해보지 않은 사람들에겐 적용하기가 쉽다.</p><p>TDD는 이렇게 해야된다는 이미지(틀)이 있다.
반드시 툴(단위 테스트 프레임워크)을 써서 개발해야 된다. 라고 생각한다.
이러한 규칙에 얽매이는 것은 애자일 방식이 아니다.
결국엔 규칙에 얽매여 똑같은 테스트를 copy&paste 한다.
도구/규칙에 집착하다 보니 TDD가 어려워지는 것이다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://heetaek.com/tags/tdd/>TDD</a></li><li><a href=https://heetaek.com/tags/unit-test/>Unit Test</a></li></ul><nav class=paginav><a class=next href=https://heetaek.com/post/algorithm-complexity/><span class=title>다음 페이지 »</span><br><span>[알고리즘] 시간 복잡도</span></a></nav></footer><script src=https://utteranc.es/client.js repo=sosolyht/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://heetaek.com>heetaek.com</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="복사";function s(){e.innerText="복사완료!",setTimeout(()=>{e.innerText="복사"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>