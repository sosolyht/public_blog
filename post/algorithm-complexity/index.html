<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘] 시간 복잡도 | 희택의 노력</title><meta name=keywords content="컴퓨터 사이언스,시간복잡도,공간복잡도,빅오 표기법,Big O,Time Complexity"><meta name=description content="알고리즘 복잡도 알고리즘 복잡도에는 시간 복잡도 (알고리즘 실행 속도) 공간 복잡도 (알고리즘이 사용하는 메모리 사이즈) 이 두 가지가 있다. 이 중에서 가장 중요한"><meta name=author content="최희택"><link rel=canonical href=https://heetaek.com/post/algorithm-complexity/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://heetaek.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heetaek.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heetaek.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heetaek.com/apple-touch-icon.png><link rel=mask-icon href=https://heetaek.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-QPR5XGZ8DK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QPR5XGZ8DK",{anonymize_ip:!1})}</script><meta property="og:title" content="[알고리즘] 시간 복잡도"><meta property="og:description" content="알고리즘 복잡도 알고리즘 복잡도에는 시간 복잡도 (알고리즘 실행 속도) 공간 복잡도 (알고리즘이 사용하는 메모리 사이즈) 이 두 가지가 있다. 이 중에서 가장 중요한"><meta property="og:type" content="article"><meta property="og:url" content="https://heetaek.com/post/algorithm-complexity/"><meta property="og:image" content="https://heetaek.com/profile.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-08T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-08T00:00:00+00:00"><meta property="og:site_name" content="희택의 노력"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://heetaek.com/profile.png"><meta name=twitter:title content="[알고리즘] 시간 복잡도"><meta name=twitter:description content="알고리즘 복잡도 알고리즘 복잡도에는 시간 복잡도 (알고리즘 실행 속도) 공간 복잡도 (알고리즘이 사용하는 메모리 사이즈) 이 두 가지가 있다. 이 중에서 가장 중요한"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://heetaek.com/post/"},{"@type":"ListItem","position":3,"name":"[알고리즘] 시간 복잡도","item":"https://heetaek.com/post/algorithm-complexity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘] 시간 복잡도","name":"[알고리즘] 시간 복잡도","description":"알고리즘 복잡도 알고리즘 복잡도에는 시간 복잡도 (알고리즘 실행 속도) 공간 복잡도 (알고리즘이 사용하는 메모리 사이즈) 이 두 가지가 있다. 이 중에서 가장 중요한","keywords":["컴퓨터 사이언스","시간복잡도","공간복잡도","빅오 표기법","Big O","Time Complexity"],"articleBody":"알고리즘 복잡도 알고리즘 복잡도에는\n시간 복잡도 (알고리즘 실행 속도) 공간 복잡도 (알고리즘이 사용하는 메모리 사이즈) 이 두 가지가 있다.\n이 중에서 가장 중요한 시간 복잡도를 꼭 이해해야한다.\n시간복잡도 코딩을 하다보면 ‘이것보다 더 좋은방법은 없을까?’ 아니면 ‘이게 최선인가?’ 라고 고민을 많이 하게된다.\n이러한 고민을 하는게 시간복잡도를 고민한다는 것과 같은 말인것같다.\n시간복잡도에서 가장 영향을 많이 미치는건 반복문이다.\n자동차로 출근하기까지의 과정을 예시로 들어보면\n자동차 문 열기 시동걸기 회사까지 이동 주차 시동끄기 자동차 문 잠그기 가장 많은 시간을 소요하는건 사람마다 다르겠지만 보통 3. 회사까지 이동 일것이다.\n3번과 같이 input 이 커지면 반복문이 알고리즘 수행 시간을 지배하게된다.\n저런 알고리즘을 프로그램화시켜서 만들게 된다면 하드웨어나 운영체제의 영향을 받아 어떤 사람은 결과가 빠르게 나올것이고 어떤 사람은 느리게 나오는 결과가 나온다.\n그래서 알고리즘의 실행 시간을 알 수 있는방법이\n빅오(Big-O) 표기법이다.\nBig-O 표기법 Big-O(빅-오) ⇒ 점근적 상한\n알고리즘 최악의 실행시간을 표시 가장 많이, 일반적으로 사용함 Big-Ω(빅-오메가) ⇒ 점근적 하한\nBig-θ(빅-세타) ⇒ 그 둘의 평균\n시간복잡도는 반복문이 핵심이므로 계산 표기 중 최상, 평균, 최악 중 최악의 시간인 Big-O 를 중점적으로 생각하면 될 것같다. Big-O 는 이 정도의 시간이 걸린다 보단 이 정도 시간까지 걸릴 수 있다 를 고려해야한다. 최선의 경우를 고려했을시 예를 들어 최선의 경우는 1초, 평균적으로 1분 , 최악일 경우 1시간이 걸리는 알고리즘을 구현했고, 최선의 경우를 생각해 알고리즘을 100번 실행했다면 100초가 걸려야 정상인데, 1시간이 걸린다면 어디에서 문제가 발생했는지 로직의 많은 부분을 파악해야하므로 문제를 해결하는데 많은 시간이 소요된다.\n평균의 경우를 고려했을시 평균의 경우는 1분이 걸리는 알고리즘이므로 100번 실행했을시 100분의 시간이 소요될거라 생각했는데, 최악의 경우가 발생하여 더 오래걸린다면 최선의 경우와 같은 고민을 하고 문제 해결에 시간이 소요된다.\n최악의 경우를 고려했을시 위의 최선 과 평균 의 예시를 보다시피 최악 의 경우가 발생하지 않기를 바라면서 코딩을 하는것보다 최악의 경우를 대비 하며 코딩하는것이 맞다고 생각한다. 쉽게 말해 Big-O 는 최악의 경우에도 이 정도의 퍼포먼스는 보장한다라는 것이다.\nBig-O 표기법 종류 O(1) O(log n) O(n) O(n2) O(2n) O(1) O(1) 은 입력 값이 증가하더라도 시간이 늘어나지 않는다.\nex)\ndef test(n): return int(n * (n + 1) / 2) test(3) 결과\n6\n입력 n이 어떻든 간에 반복문이 없기때문에 시간복잡도는 1 이다.\n빅오 표기법으로는 O(1) 입니다.\nO(log n) Big-O표기법중 O(1) 다음으로 빠른 시간 복잡도를 가집니다.\nn 개의 크기 순으로 정렬된 배열에서 특정 값을 찾기 위해 이진 탐색\n이해하기 쉬운 게임으로 비유해 보자면 업다운을 예로 들 수 있습니다. 1~100 중 하나의 숫자를 플레이어1이 고른다 (30을 골랐다고 가정) 50(가운데) 숫자를 제시하면 50보다 작으므로 down을 외친다 1~50중의 하나의 숫자이므로 또다시 경우의 수를 절반으로 줄이기 위해 25를 제시한다 25보다 크므로 up을 외친다 경우의 수를 계속 절반으로 줄여나가며 정답을 찾는다 O(n) O(n) 은 입력 값이 증가함에 따라 시간도 같이 증가하는 것을 의미합니다.\ndef test(n): total = 0 for num in range(1, n + 1): total += num return total test(3) 결과\n6\n입력 n 에 따라 n 번을 반복문을 사용해 더해야합니다.\n따라서, 시간복잡도는 1 빅오 표기법은 O(n) 입니다.\nO(n2) 입력 값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미합니다.\ndef test(li): for n in li: for m in li: return n,m 반복문이 두 번 있으면 O(n2)\n반복문이 세 번 있으면 O(n3)\n…\n반복문 백 번 있으면 O(n100) 이지만, n 이 커질수록 지수가 주는 영향력이 없어지기 때문에,\n그냥 n2 라고 표기합니다.\nO(2n) Big-O 표기법 중 가장 느린 시간 복잡도를 가지고있습니다.\ndef test(n): if n == 0: return 0 elif n == 1 or n == 2: return 1 else: return fib(n - 1) + fib(n - 2) 재귀 함수를 통해 구현한 피보나치 수열은 O(2n) 의 시간 복잡도를 가지고있습니다.\n위의 사진을 보면 차트가 가파르게 올라가는데 n 의 값이 커지면 시간 복잡도도 같이 증가하기 때문입니다.\n간단한 예시를 들면, 종이를 42번 접으면 두께가 지구에서 달까지 갈 만큼 커진다는 이야기가 있는데 그만한 두께를 가질 수 있는 이유는 매번 접을 때마다 2배로 늘어나기 때문입니다.\nReference\nhttps://psychoria.tistory.com/770 https://blog.chulgil.me/algorithm/ https://data-marketing-bk.tistory.com/27 ","wordCount":"1679","inLanguage":"ko","datePublished":"2022-05-08T00:00:00Z","dateModified":"2022-05-08T00:00:00Z","author":{"@type":"Person","name":"최희택"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://heetaek.com/post/algorithm-complexity/"},"publisher":{"@type":"Organization","name":"희택의 노력","logo":{"@type":"ImageObject","url":"https://heetaek.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://heetaek.com accesskey=h title="heetaek.com (Alt + H)">heetaek.com</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://heetaek.com/categories/ title=카테고리><span>카테고리</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://heetaek.com>Home</a>&nbsp;»&nbsp;<a href=https://heetaek.com/post/>Posts</a></div><h1 class=post-title>[알고리즘] 시간 복잡도</h1><div class=post-meta><span title='2022-05-08 00:00:00 +0000 UTC'>2022-05-08</span>&nbsp;·&nbsp;4 분&nbsp;·&nbsp;최희택</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%b3%b5%ec%9e%a1%eb%8f%84 aria-label="알고리즘 복잡도">알고리즘 복잡도</a><ul><li><a href=#%ec%8b%9c%ea%b0%84%eb%b3%b5%ec%9e%a1%eb%8f%84 aria-label=시간복잡도>시간복잡도</a></li><li><a href=#big-o-%ed%91%9c%ea%b8%b0%eb%b2%95 aria-label="Big-O 표기법">Big-O 표기법</a><ul><li><a href=#%ec%b5%9c%ec%84%a0%ec%9d%98-%ea%b2%bd%ec%9a%b0%eb%a5%bc-%ea%b3%a0%eb%a0%a4%ed%96%88%ec%9d%84%ec%8b%9c aria-label="최선의 경우를 고려했을시">최선의 경우를 고려했을시</a></li><li><a href=#%ed%8f%89%ea%b7%a0%ec%9d%98-%ea%b2%bd%ec%9a%b0%eb%a5%bc-%ea%b3%a0%eb%a0%a4%ed%96%88%ec%9d%84%ec%8b%9c aria-label="평균의 경우를 고려했을시">평균의 경우를 고려했을시</a></li><li><a href=#%ec%b5%9c%ec%95%85%ec%9d%98-%ea%b2%bd%ec%9a%b0%eb%a5%bc-%ea%b3%a0%eb%a0%a4%ed%96%88%ec%9d%84%ec%8b%9c aria-label="최악의 경우를 고려했을시">최악의 경우를 고려했을시</a></li></ul></li><li><a href=#big-o-%ed%91%9c%ea%b8%b0%eb%b2%95-%ec%a2%85%eb%a5%98 aria-label="Big-O 표기법 종류">Big-O 표기법 종류</a><ul><li><a href=#o1 aria-label=O(1)>O(1)</a></li><li><a href=#olog-n aria-label="O(log n)">O(log n)</a></li><li><a href=#on aria-label=O(n)>O(n)</a></li><li><a href=#on2 aria-label=O(n2)>O(n2)</a></li><li><a href=#o2n aria-label=O(2n)>O(2n)</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=알고리즘-복잡도>알고리즘 복잡도<a hidden class=anchor aria-hidden=true href=#알고리즘-복잡도>#</a></h1><p>알고리즘 복잡도에는</p><ul><li>시간 복잡도 (알고리즘 실행 속도)</li><li>공간 복잡도 (알고리즘이 사용하는 메모리 사이즈)</li></ul><p>이 두 가지가 있다.</p><p>이 중에서 가장 중요한 시간 복잡도를 꼭 이해해야한다.</p><h2 id=시간복잡도>시간복잡도<a hidden class=anchor aria-hidden=true href=#시간복잡도>#</a></h2><p>코딩을 하다보면 &lsquo;이것보다 더 좋은방법은 없을까?&rsquo; 아니면 &lsquo;이게 최선인가?&rsquo; 라고 고민을 많이 하게된다.</p><p>이러한 고민을 하는게 <strong>시간복잡도</strong>를 고민한다는 것과 같은 말인것같다.</p><p>시간복잡도에서 가장 영향을 많이 미치는건 반복문이다.</p><blockquote><p>자동차로 출근하기까지의 과정을 예시로 들어보면</p><ol><li>자동차 문 열기</li><li>시동걸기</li><li>회사까지 이동</li><li>주차</li><li>시동끄기</li><li>자동차 문 잠그기</li></ol></blockquote><p>가장 많은 시간을 소요하는건 사람마다 다르겠지만 보통 <code>3. 회사까지 이동</code> 일것이다.</p><p>3번과 같이 input 이 커지면 반복문이 알고리즘 수행 시간을 지배하게된다.</p><p>저런 알고리즘을 프로그램화시켜서 만들게 된다면 하드웨어나 운영체제의 영향을 받아 어떤 사람은 결과가 빠르게 나올것이고 어떤 사람은 느리게 나오는 결과가 나온다.</p><p>그래서 알고리즘의 실행 시간을 알 수 있는방법이</p><p><strong>빅오(Big-O)</strong> 표기법이다.</p><h2 id=big-o-표기법>Big-O 표기법<a hidden class=anchor aria-hidden=true href=#big-o-표기법>#</a></h2><ul><li><p>Big-O(빅-오) ⇒ 점근적 상한</p><ul><li>알고리즘 최악의 실행시간을 표시</li><li>가장 많이, 일반적으로 사용함</li></ul></li><li><p>Big-Ω(빅-오메가) ⇒ 점근적 하한</p></li><li><p>Big-θ(빅-세타) ⇒ 그 둘의 평균</p></li></ul><blockquote><ul><li>시간복잡도는 반복문이 핵심이므로 계산 표기 중 <code>최상</code>, <code>평균</code>, <code>최악</code> 중
최악의 시간인 Big-O 를 중점적으로 생각하면 될 것같다.</li><li>Big-O 는 <code>이 정도의 시간이 걸린다</code> 보단 <code>이 정도 시간까지 걸릴 수 있다</code> 를 고려해야한다.</li></ul></blockquote><h3 id=최선의-경우를-고려했을시>최선의 경우를 고려했을시<a hidden class=anchor aria-hidden=true href=#최선의-경우를-고려했을시>#</a></h3><p>예를 들어 최선의 경우는 1초, 평균적으로 1분 , 최악일 경우 1시간이 걸리는 알고리즘을 구현했고, 최선의 경우를 생각해 알고리즘을 100번 실행했다면 100초가 걸려야 정상인데, 1시간이 걸린다면 어디에서 문제가 발생했는지 로직의 많은 부분을 파악해야하므로 문제를 해결하는데 많은 시간이 소요된다.</p><h3 id=평균의-경우를-고려했을시>평균의 경우를 고려했을시<a hidden class=anchor aria-hidden=true href=#평균의-경우를-고려했을시>#</a></h3><p>평균의 경우는 1분이 걸리는 알고리즘이므로 100번 실행했을시 100분의 시간이 소요될거라 생각했는데,
최악의 경우가 발생하여 더 오래걸린다면 최선의 경우와 같은 고민을 하고 문제 해결에 시간이 소요된다.</p><h3 id=최악의-경우를-고려했을시>최악의 경우를 고려했을시<a hidden class=anchor aria-hidden=true href=#최악의-경우를-고려했을시>#</a></h3><p>위의 <code>최선</code> 과 <code>평균</code> 의 예시를 보다시피 <code>최악</code> 의 경우가 발생하지 않기를 바라면서 코딩을 하는것보다
<strong>최악의 경우를 대비</strong> 하며 코딩하는것이 맞다고 생각한다.
쉽게 말해 Big-O 는 <strong>최악의 경우에도 이 정도의 퍼포먼스는 보장</strong>한다라는 것이다.</p><h2 id=big-o-표기법-종류>Big-O 표기법 종류<a hidden class=anchor aria-hidden=true href=#big-o-표기법-종류>#</a></h2><blockquote><ol><li>O(1)</li><li>O(log n)</li><li>O(n)</li><li>O(n2)</li><li>O(2n)</li></ol></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/2377807/167562741-8cce73c6-78e8-4872-ab9f-9a4aed581f0a.png alt=빅오표기법></p><hr><h3 id=o1>O(1)<a hidden class=anchor aria-hidden=true href=#o1>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/2377807/167563841-a90782fb-c76b-41f6-9a74-7ddc19daf249.png alt=O(1)></p><blockquote><p>O(1) 은 입력 값이 증가하더라도 시간이 늘어나지 않는다.</p></blockquote><p>ex)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>int</span>(n <span style=color:#ff79c6>*</span> (n <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test(<span style=color:#bd93f9>3</span>)
</span></span></code></pre></div><p>결과</p><p><code>6</code></p><p>입력 n이 어떻든 간에 반복문이 없기때문에 시간복잡도는 <code>1</code> 이다.</p><p>빅오 표기법으로는 O(1) 입니다.</p><hr><h3 id=olog-n>O(log n)<a hidden class=anchor aria-hidden=true href=#olog-n>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/2377807/167571650-f4e9c109-6f3b-433d-ad6c-706b4ed691dc.png alt="O(log n)"></p><blockquote><p>Big-O표기법중 O(1) 다음으로 빠른 시간 복잡도를 가집니다.</p></blockquote><p>n 개의 크기 순으로 정렬된 배열에서 특정 값을 찾기 위해 이진 탐색</p><ul><li>이해하기 쉬운 게임으로 비유해 보자면 업다운을 예로 들 수 있습니다.</li></ul><ol><li>1~100 중 하나의 숫자를 플레이어1이 고른다 (30을 골랐다고 가정)</li><li>50(가운데) 숫자를 제시하면 50보다 작으므로 down을 외친다</li><li>1~50중의 하나의 숫자이므로 또다시 경우의 수를 절반으로 줄이기 위해 25를 제시한다</li><li>25보다 크므로 up을 외친다</li><li>경우의 수를 계속 절반으로 줄여나가며 정답을 찾는다</li></ol><hr><h3 id=on>O(n)<a hidden class=anchor aria-hidden=true href=#on>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/2377807/167566439-60c0d8ba-0d95-4936-b8bf-32cf7d2d942b.png alt=O(n)></p><blockquote><p>O(n) 은 입력 값이 증가함에 따라 시간도 같이 증가하는 것을 의미합니다.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test</span>(n):
</span></span><span style=display:flex><span>    total <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> num <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#bd93f9>1</span>, n <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>):
</span></span><span style=display:flex><span>        total <span style=color:#ff79c6>+=</span> num
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> total
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test(<span style=color:#bd93f9>3</span>)
</span></span></code></pre></div><p>결과</p><p><code>6</code></p><p>입력 n 에 따라 n 번을 반복문을 사용해 더해야합니다.</p><p>따라서, 시간복잡도는 <code>1</code> 빅오 표기법은 O(n) 입니다.</p><hr><h3 id=on2>O(n2)<a hidden class=anchor aria-hidden=true href=#on2>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/2377807/167600859-19c920de-78ab-473d-bdff-d23264e89275.png alt=O(n2)></p><blockquote><p>입력 값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미합니다.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test</span>(li):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> n <span style=color:#ff79c6>in</span> li:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> m <span style=color:#ff79c6>in</span> li:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> n,m
</span></span></code></pre></div><p>반복문이 두 번 있으면 O(n2)</p><p>반복문이 세 번 있으면 O(n3)</p><p>&mldr;</p><p>반복문 백 번 있으면 O(n100) 이지만, n 이 커질수록 지수가 주는 영향력이 없어지기 때문에,</p><p>그냥 n2 라고 표기합니다.</p><hr><h3 id=o2n>O(2n)<a hidden class=anchor aria-hidden=true href=#o2n>#</a></h3><p><img loading=lazy src=https://user-images.githubusercontent.com/2377807/167605731-f6d50fc3-4dc9-47ac-a829-4d1d57fba8b1.png alt=O(2n)></p><blockquote><p>Big-O 표기법 중 가장 느린 시간 복잡도를 가지고있습니다.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>elif</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span> <span style=color:#ff79c6>or</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> fib(n <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>+</span> fib(n <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>2</span>)
</span></span></code></pre></div><p>재귀 함수를 통해 구현한 피보나치 수열은 O(2n) 의 시간 복잡도를 가지고있습니다.</p><p>위의 사진을 보면 차트가 가파르게 올라가는데 n 의 값이 커지면 시간 복잡도도 같이 증가하기 때문입니다.</p><p>간단한 예시를 들면, 종이를 42번 접으면 두께가 지구에서 달까지 갈 만큼 커진다는 이야기가 있는데 그만한 두께를 가질 수 있는 이유는 매번 접을 때마다 2배로 늘어나기 때문입니다.</p><blockquote><p>Reference</p></blockquote><ul><li><a href=https://psychoria.tistory.com/770>https://psychoria.tistory.com/770</a></li><li><a href=https://blog.chulgil.me/algorithm/>https://blog.chulgil.me/algorithm/</a></li><li><a href=https://data-marketing-bk.tistory.com/27>https://data-marketing-bk.tistory.com/27</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://heetaek.com/tags/computer-science/>Computer Science</a></li><li><a href=https://heetaek.com/tags/%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4/>컴퓨터 사이언스</a></li><li><a href=https://heetaek.com/tags/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/>시간복잡도</a></li><li><a href=https://heetaek.com/tags/%EB%B9%85%EC%98%A4%ED%91%9C%EA%B8%B0%EB%B2%95/>빅오표기법</a></li><li><a href=https://heetaek.com/tags/big-o/>Big O</a></li><li><a href=https://heetaek.com/tags/time-complexity/>Time Complexity</a></li></ul><nav class=paginav><a class=prev href=https://heetaek.com/post/tdd/><span class=title>« 이전 페이지</span><br><span>TDD 는 왜 필요한가?</span></a>
<a class=next href=https://heetaek.com/post/data-structure-algoithm/><span class=title>다음 페이지 »</span><br><span>[자료구조] 자료구조(Data Structure)란?</span></a></nav></footer><script src=https://utteranc.es/client.js repo=sosolyht/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://heetaek.com>heetaek.com</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="복사";function s(){t.innerText="복사완료!",setTimeout(()=>{t.innerText="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>